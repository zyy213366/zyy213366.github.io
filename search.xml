<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>行知防空洞</title>
      <link href="/2025/09/19/diankongzuoye/"/>
      <url>/2025/09/19/diankongzuoye/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>行知防空洞是我和我同学在高中中从来没有去过为数不多的地方了，我们在毕业才偶然发现，啊嘞，高中还有这么个地方吗？？怎么从没听说过，作为三年行知人，还是不能接受这种事情的发生的，所以想抽时间和同学去一下。</p><h3 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h3><p>当时第一次去是暑假开始，高中生们都休假回家了，我们作为大一生们被母校拒之门外，本想拿高三刚毕业来搪塞过去，但在我们前面的纯种毕业生都没进去，所以最后不得不放弃这个办法。想了很久，总归是不能放弃，我和同学就绕着学校走，走了一圈又一圈，终是在学校的第二道门游泳馆找到了突破口，当时游泳馆没有关，我们从游泳馆进了学校，一路走到了防空洞，本身是可以进去的，但当时情况特殊，装备也没带齐，两个人也并不安全，踌躇挺久的，还是出了学校，这也算是失败的经历。</p><h3 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h3><p>军训完本来都把防空洞的事情淡忘了，但偶然同学又提起，又重新燃起希望了，本身开学之后进去比较简单，同时这次去的人比较多，如果出什么事故也比较好接应，于是我和同学就直接下洞。<br>总的来说防空洞下面没啥东西，但是有很多不知名同学在不知什么年代的涂鸦，甚至有人把自己高考成绩单扔在防空洞里，简直匪夷所思。几处普通房间里放置了保温水杯，动物的腐烂尸体和正上方教学楼同学们课间的鬼叫给我们这次可以称得上探险的行动增添了一抹奇幻色彩。曾不止一次听说最近行知高一高二课间总是来防空洞玩手机啥的，有时候我就在想当时我们高三要是知道这里并且天天来的话，我们枯燥的生活会有什么不同，或许并不会有什么改变吧，但是这次两个人下洞的冒险可能会变成几个人或一群人，我还是希望能把这段经历放到高三，当时探索防空洞这种新奇的经历对于我们来说比现在更重要，如今我们去看以前没看过的学校角落或者新鲜事件，都只能用一种回归的姿态，甚至作客的视角去观察，其实还是有些遗憾的。<br>但话也说回来，来过总比没去过强，行知防空洞现在也算是我进过的第一个防空洞了。</p><h3 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h3><p><img src="/img/9bdd6ea53a14424e119f62add6a91d60.jpg" alt="地图"><br><img src="/img/9c08421dc76213fc87b3f8e83417dd59.jpg" alt="倒吊人"><br><img src="/img/162babd2f7ecc14b414f0a7cae4969f3.jpg" alt="涂鸦"><br><img src="/img/da30b6d8032a60c006a913ebb462e8dc.jpg" alt="走廊"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2025/08/14/hash/"/>
      <url>/2025/08/14/hash/</url>
      
        <content type="html"><![CDATA[<h3 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h3><p>现实生活中我们往往有很多账户，而每一个账户总是需要一个与之匹配的密码，但对于系统来说，它需要存储的账户以及密码就有千千万万，为了提高效率，在实际使用中总是用哈希表来存储密码。<br>哈希表就是把密码按照一个计算公式转换成一个独一无二的大数，然后用户输入密码，按同样的公式进行计算，算出来与这个大数比对，得出是否是同一密码。这样做的优势是原本比对密码需要一位一位比对，效率低下，而如今的比对方式则快很多，直接两个值比对，会快很多。<br>但在实际应用中，会有极小极小概率两个密码算出来的哈希值是一样的，这时候我们就需要双哈希，对于每一个密码进行两遍哈希运算，然后把值进行比较，这样哈希碰撞的概率可以近乎为0。下面是示例代码，哈希表在c++中的应用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ============================</span></span><br><span class="line"><span class="comment">  教学目标</span></span><br><span class="line"><span class="comment">  1) “哈希表哈希公式 + 取模”：把键(用户名)映射到桶</span></span><br><span class="line"><span class="comment">     index_hash(name) = ( ... ) % M</span></span><br><span class="line"><span class="comment">  2) “口令摘要哈希 + 取模”：把 salt|password 映射到 64bit/十六进制字符串</span></span><br><span class="line"><span class="comment">     pw_hash(salt, pwd) = ( ... ) % MOD  (并迭代多轮)</span></span><br><span class="line"><span class="comment">  3) 冲突处理：分离链接法（vector&lt;list&lt;...&gt;&gt;）</span></span><br><span class="line"><span class="comment">  ============================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 工具函数 ==========</span></span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">to_hex64</span><span class="params">(<span class="type">uint64_t</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* hex = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="number">16</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">15</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        s[i] = hex[x &amp; <span class="number">0xF</span>];</span><br><span class="line">        x &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">gen_salt</span><span class="params">(<span class="type">size_t</span> len = <span class="number">16</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> pool[] =</span><br><span class="line">        <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789./&quot;</span>;</span><br><span class="line">    <span class="type">static</span> random_device rd;</span><br><span class="line">    <span class="function"><span class="type">static</span> mt19937_64 <span class="title">rng</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">0</span>, (<span class="type">int</span>)<span class="keyword">sizeof</span>(pool) - <span class="number">2</span>)</span></span>;</span><br><span class="line">    string s; s.<span class="built_in">reserve</span>(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i) s.<span class="built_in">push_back</span>(pool[<span class="built_in">dist</span>(rng)]);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 口令哈希（教学版，非生产！） ==========</span></span><br><span class="line"><span class="comment">// 公式：H = (H * BASE + byte) % MOD</span></span><br><span class="line"><span class="comment">// 注意：BASE 必须 &lt; MOD</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimplePasswordHasher</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> MOD  = <span class="number">1000000007ULL</span>;   <span class="comment">// 大素数</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">uint64_t</span> BASE = <span class="number">315423904ULL</span>;    <span class="comment">// 1315423911 % 1e9+7（取 &lt; MOD 的值）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title">hash_once</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint64_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> c : s) &#123;</span><br><span class="line">            h = (h * BASE + c) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的 key stretching：多轮迭代（演示）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> string <span class="title">hash_password</span><span class="params">(<span class="type">const</span> string&amp; salt, <span class="type">const</span> string&amp; password, <span class="type">int</span> rounds = <span class="number">10000</span>)</span> </span>&#123;</span><br><span class="line">        string mix = salt + <span class="string">&quot;#&quot;</span> + password;</span><br><span class="line">        <span class="type">uint64_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rounds; ++i) &#123;</span><br><span class="line">            <span class="comment">// 每一轮把上轮结果拼回去再哈希（演示思路）</span></span><br><span class="line">            string t = mix + <span class="string">&quot;|&quot;</span> + <span class="built_in">to_hex64</span>(h);</span><br><span class="line">            h = <span class="built_in">hash_once</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_hex64</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 哈希表：分离链接法 ==========</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UserEntry</span> &#123;</span><br><span class="line">    string username;</span><br><span class="line">    string salt;</span><br><span class="line">    string pw_hash_hex; <span class="comment">// SimplePasswordHasher 产出的十六进制摘要（教学用途）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTableUsers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 桶数：素数（减少冲突）；你可以改大些，例如 100003</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HashTableUsers</span><span class="params">(<span class="type">size_t</span> bucket_count = <span class="number">10007</span>)</span></span></span><br><span class="line"><span class="function">        : M(bucket_count), buckets(bucket_count) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入或更新用户</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">upsert</span><span class="params">(<span class="type">const</span> string&amp; username, <span class="type">const</span> string&amp; password)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> idx = <span class="built_in">index_hash</span>(username);</span><br><span class="line">        <span class="keyword">auto</span>&amp; lst = buckets[idx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : lst) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.username == username) &#123;</span><br><span class="line">                <span class="comment">// 更新口令</span></span><br><span class="line">                e.salt = <span class="built_in">gen_salt</span>();</span><br><span class="line">                e.pw_hash_hex = SimplePasswordHasher::<span class="built_in">hash_password</span>(e.salt, password);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新增</span></span><br><span class="line">        UserEntry e;</span><br><span class="line">        e.username = username;</span><br><span class="line">        e.salt = <span class="built_in">gen_salt</span>();</span><br><span class="line">        e.pw_hash_hex = SimplePasswordHasher::<span class="built_in">hash_password</span>(e.salt, password);</span><br><span class="line">        lst.<span class="built_in">push_front</span>(std::<span class="built_in">move</span>(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验登录</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verify</span><span class="params">(<span class="type">const</span> string&amp; username, <span class="type">const</span> string&amp; password)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> UserEntry* e = <span class="built_in">find_user</span>(username);</span><br><span class="line">        <span class="keyword">if</span> (!e) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        string h = SimplePasswordHasher::<span class="built_in">hash_password</span>(e-&gt;salt, password);</span><br><span class="line">        <span class="keyword">return</span> h == e-&gt;pw_hash_hex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> string&amp; username)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> idx = <span class="built_in">index_hash</span>(username);</span><br><span class="line">        <span class="keyword">auto</span>&amp; lst = buckets[idx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = lst.<span class="built_in">begin</span>(); it != lst.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;username == username) &#123;</span><br><span class="line">                lst.<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试/查看：把每个桶里的人数统计一下</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">size_t</span>&gt; <span class="title">bucket_sizes_sample</span><span class="params">(<span class="type">size_t</span> first_k = <span class="number">20</span>)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        first_k = <span class="built_in">min</span>(first_k, M);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">size_t</span>&gt; <span class="title">a</span><span class="params">(first_k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; first_k; ++i) a[i] = buckets[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> M;</span><br><span class="line">    vector&lt;list&lt;UserEntry&gt;&gt; buckets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ====== 哈希表索引的哈希公式（重点：含“取模”）======</span></span><br><span class="line">    <span class="comment">// 经典的多项式滚动：h = (h * B + byte) % M</span></span><br><span class="line">    <span class="comment">// 这里 M 是桶数（素数），B 选个小质数即可，比如 131</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">index_hash</span><span class="params">(<span class="type">const</span> string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> B = <span class="number">131</span>;      <span class="comment">// 小质数</span></span><br><span class="line">        <span class="type">uint64_t</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> c : key) &#123;</span><br><span class="line">            h = (h * B + c) % M;     <span class="comment">// —— 关键的“取模 M” —— 把哈希值映射到 [0, M)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">size_t</span>)h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> UserEntry* <span class="title">find_user</span><span class="params">(<span class="type">const</span> string&amp; username)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> idx = <span class="built_in">index_hash</span>(username);</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; lst = buckets[idx];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : lst) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.username == username) <span class="keyword">return</span> &amp;e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 演示 ==========</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">HashTableUsers <span class="title">db</span><span class="params">(<span class="number">10007</span>)</span></span>; <span class="comment">// 1 万级桶，素数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;简易账户系统（教学 demo）\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;命令：\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot; 1 signup &lt;username&gt; &lt;password&gt;\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot; 2 login  &lt;username&gt; &lt;password&gt;\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot; 3 chpwd  &lt;username&gt; &lt;new_password&gt;\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot; 4 del    &lt;username&gt;\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot; 5 stat   （查看前 20 个桶的尺寸）\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot; 0 exit\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        string cmd;</span><br><span class="line">        <span class="keyword">if</span> (!(cin &gt;&gt; cmd)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="string">&quot;0&quot;</span> || cmd == <span class="string">&quot;exit&quot;</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="string">&quot;signup&quot;</span> || cmd == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">            string u, p; cin &gt;&gt; u &gt;&gt; p;</span><br><span class="line">            db.<span class="built_in">upsert</span>(u, p);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;OK: user &#x27;&quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot;&#x27; created/updated.\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;login&quot;</span> || cmd == <span class="string">&quot;2&quot;</span>) &#123;</span><br><span class="line">            string u, p; cin &gt;&gt; u &gt;&gt; p;</span><br><span class="line">            cout &lt;&lt; (db.<span class="built_in">verify</span>(u, p) ? <span class="string">&quot;Login success\n&quot;</span> : <span class="string">&quot;Login failed\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;chpwd&quot;</span> || cmd == <span class="string">&quot;3&quot;</span>) &#123;</span><br><span class="line">            string u, p; cin &gt;&gt; u &gt;&gt; p;</span><br><span class="line">            db.<span class="built_in">upsert</span>(u, p);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;OK: password updated for &#x27;&quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot;&#x27;.\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;del&quot;</span> || cmd == <span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">            string u; cin &gt;&gt; u;</span><br><span class="line">            cout &lt;&lt; (db.<span class="built_in">erase</span>(u) ? <span class="string">&quot;Deleted\n&quot;</span> : <span class="string">&quot;No such user\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;stat&quot;</span> || cmd == <span class="string">&quot;5&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> v = db.<span class="built_in">bucket_sizes_sample</span>(<span class="number">20</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;First 20 buckets sizes: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i) cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">                cout &lt;&lt; v[i];</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Unknown cmd\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所谓加盐就是对于每一个密码加一个数让其更加离散代码。哈希公式 h &#x3D; (h * B + byte) % M。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acm培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集，优先队列，双端队列</title>
      <link href="/2025/08/07/deque/"/>
      <url>/2025/08/07/deque/</url>
      
        <content type="html"><![CDATA[<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>当我们碰到堆的划分问题时候我们可以用到并查集，其实就是每个节点通过一个父节点来存储信息，然后通过递归的方法将一个堆中所有子节点或叶子节点的父节点全部指向根节点，而根节点的父节点指向自己。<br>本来我没有了解到这一层的时候认为堆的合并将会是很困难的事，因为每个父节点是不一样的，但现在就好办了，我们只要把两个根节点给合并，最后再递归一下就算成功了。<br>它的时间复杂度比o（log n）很快，是反阿克曼函数，接近于o（1）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_set</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[i] == i) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> fa[i] = <span class="built_in">find_set</span>(fa[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">union_set</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = <span class="built_in">find_set</span>(a);</span><br><span class="line">    b = <span class="built_in">find_set</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (a != b) fa[b] = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是并查集的设置和合并，有趣的一个点是合并不会立刻发生，原来第二堆的值仍然指向第二个根节点，而第二个根节点指向第一个，真正完全的合并在之后再次查询并查集时候find_set上自动操作的。</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列两边都能进出元素，就是队列和栈的集合，直接来用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Deque dq;</span><br><span class="line"></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Front: &quot;</span> &lt;&lt; dq.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Back: &quot;</span> &lt;&lt; dq.<span class="built_in">back</span>() &lt;&lt; endl;    <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;New Front: &quot;</span> &lt;&lt; dq.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    dq.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;New Back: &quot;</span> &lt;&lt; dq.<span class="built_in">back</span>() &lt;&lt; endl;    <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; dq.<span class="built_in">size</span>() &lt;&lt; endl;        <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列本质是通过红黑树来实现的，默认是从大到小排序的队列，实际也不能说是排序，其中只有最大值是有序的，我拿出最大值之后又是新的最大值有序（在顶层），这样看上去像是排完了序，这种被称为堆排序。时间复杂度o(log n)。<br>我们来看用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::greater</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val, priority;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> v, <span class="type">int</span> p) : <span class="built_in">val</span>(v), <span class="built_in">priority</span>(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数，用于优先级队列中从小到大排列</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node&amp; a, <span class="type">const</span> Node&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.priority &gt; b.priority; <span class="comment">// 小优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 默认大根堆（从大到小）</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; maxHeap;</span><br><span class="line">    maxHeap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    maxHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    maxHeap.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大根堆: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!maxHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; maxHeap.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 小根堆（从小到大）</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    minHeap.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小根堆: &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; minHeap.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 自定义结构体优先队列（根据 priority 从小到大）</span></span><br><span class="line">    priority_queue&lt;Node, vector&lt;Node&gt;, Compare&gt; customHeap;</span><br><span class="line">    customHeap.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">100</span>, <span class="number">5</span>));</span><br><span class="line">    customHeap.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">200</span>, <span class="number">1</span>));</span><br><span class="line">    customHeap.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">300</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;结构体小根堆 (按 priority): &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!customHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node node = customHeap.<span class="built_in">top</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; node.val &lt;&lt; <span class="string">&quot;, priority=&quot;</span> &lt;&lt; node.priority &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        customHeap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>over</p>]]></content>
      
      
      
        <tags>
            
            <tag> acm培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论的一些很基础知识</title>
      <link href="/2025/08/06/boyilun/"/>
      <url>/2025/08/06/boyilun/</url>
      
        <content type="html"><![CDATA[<h3 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h3><p>公平组合游戏是两个人进行的游戏，回合制并且每个人操作的对象是同一个，换言之每一步状态，怎么操作都与操作者无关，两人都是全知全能，进行每一步操作时都了解后面操作的所有状态，去选择对自己最有利的解，这就叫做公平组合游戏，而基础的博弈论就是探讨这种情况的。</p><h3 id="博弈论中最基本的知识"><a href="#博弈论中最基本的知识" class="headerlink" title="博弈论中最基本的知识"></a>博弈论中最基本的知识</h3><p>在进行公平组合游戏时，每一步的状态可以概括为两种。<br>p态：后手必胜，即这个回合开始时操作者的对手一定会赢。<br>n态：先手必胜，即这个回合开始时操作者一定会赢。<br>知道这两个概念之后不难推出两个结论。</p><ol><li>能变成p态的状态一定是n态。因为每个人都想要最优解，如果前面已经先手必胜，那么等于可以选择下一回合自己变成后手必胜。当然也可以不选，那么就会输。</li><li>p态只能变成n态。这个回合我是后手必胜的状态，无法操作，但由于是必胜的状态，下一回合我操作一定是先手必胜。</li></ol><h4 id="sg函数"><a href="#sg函数" class="headerlink" title="sg函数"></a>sg函数</h4><p>sg函数是决定谁胜谁败的关键。<br>我们规定sg函数的公式为 g(x)&#x3D;mex{g(y)} 其中x表示了当前状态，y表示了所有x状态通过一步转换能变成的状态集合。<br>mex函数表示大括号中所有数的第一个非负整数，比如mex{0，1，2，3}&#x3D;4。<br>那么这个公式的作用是什么，p态出现当且仅当g(x)&#x3D;0，我也不会证明。。<br>前面的sg函数运用于一个子游戏，当一个大的组合游戏分为多个子组合游戏时，我们该如何计算其中的sg函数呢？<br>大的g(x)值是所有子游戏起点的SG值的异或（XOR）和，异或就不需要说了吧，两个1变成0，两个0还是0，1^0&#x3D;1。</p><h4 id="hash-博弈"><a href="#hash-博弈" class="headerlink" title="hash 博弈"></a>hash 博弈</h4><p>根据Bash博弈的规则，当有 n 个石子时，玩家可以取走 k 个，其中 1≤k≤x。所以，状态 n 可以转移到 n−1,n−2,…,n−x 这 x 个状态（只要这些状态 ≥0）。<br>所以sg函数是g(n)&#x3D;mex({g(n−1),g(n−2),…,g(n−x)})<br>我们慢慢枚举<br>g(0)&#x3D;0  g(1)&#x3D;mex{g(0)}&#x3D;1 g(2)&#x3D;mex{g(0),g(1)}&#x3D;2….. g(x)&#x3D;mex{g(0),g(1)….g(x-1)}&#x3D;x<br>重点来了g(x+1)&#x3D;mex{g(x)…..g(1)}&#x3D;0<br>由此可见sg函数是关于x+1的一个循环，我们知道后手必胜的条件就是g(n)&#x3D;0<br>也就是说当且仅当n&#x3D;k(x+1),k属于正整数时候才成立。</p><h4 id="nim-博弈"><a href="#nim-博弈" class="headerlink" title="nim 博弈"></a>nim 博弈</h4><p>n 堆石子，第 i 堆有 ai 个。双方轮流选择任意一堆，并从该堆中取走任意数量（但至少一个）的石子。无法操作者输 。<br>这是多个组合问题，把他先分解，看成一个个子问题来做，以一堆为研究对象。设没堆石子有k个。<br>sg函数为g(k)&#x3D;mex{g(0),g(1),g(2)…g(k-1)}&#x3D;k<br>k&#x3D;ai 那么也就是说这个数列必须满足 a1^a2^a3^….an&#x3D;0 进入后手必胜状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acm培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧几里得的游戏</title>
      <link href="/2025/08/04/oujilide/"/>
      <url>/2025/08/04/oujilide/</url>
      
        <content type="html"><![CDATA[<p>本来我是完全没有接触过博弈论的，但是今天看到了这道题，用到了Euclidean Game 定理。搜了一下，发现这玩意好像有点意思，就写一下。</p><h3 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h3><p>欧几里德的两个后代 Stan 和 Ollie 正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数 M 和 N，从 Stan 开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于 0 。然后是 Ollie，对刚才得到的数，和 M , N 中较小的那个数，再进行同样的操作……直到一个人得到了0，他就取得了胜利。下面是他们用(25,7) 两个数游戏的过程：</p><p>初始：(25,7)；<br>Stan：(11,7)；<br>Ollie：(4,7)；<br>Stan：(4,3)；<br>Ollie：(1,3)；<br>Stan：(1,0)。<br>Stan 赢得了游戏的胜利。</p><p>现在，假设他们完美地操作，谁会取得胜利呢？</p><p>Input<br>本题有多组测试数据。<br>第一行为测试数据的组数 C 。 下面 C 行，每行为一组数据，包含两个正整数 M , N(M , N&lt;2^31)M,N(M,N&lt;2^31)。</p><p>Output<br>对每组输入数据输出一行，如果 Stan 胜利，则输出 Stan wins；否则输出 Ollie wins。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (a / b &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">solve</span>(b, a % b);  <span class="comment">// 当前取一步，能不能让对方输</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(a, b)) cout &lt;&lt; <span class="string">&quot;Stan wins&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Ollie wins&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h3><p>本道题就是分成两部分，当k只能取一个值的时候取决于之后的状态，当有多个状态时候直接必胜，那么必胜的证明过程如下。<br><img src="/img/ojilide.jpg" alt="证明过程"></p>]]></content>
      
      
      
        <tags>
            
            <tag> acm培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯消元，快速幂和一些拓展</title>
      <link href="/2025/08/04/gauss/"/>
      <url>/2025/08/04/gauss/</url>
      
        <content type="html"><![CDATA[<h3 id="标准快速幂"><a href="#标准快速幂" class="headerlink" title="标准快速幂"></a>标准快速幂</h3><p>平时计算幂次时计算机的一般方法其实就是累乘，比如2^8就是2<em>2</em>2*2一直乘下去，这带来了极高的时间复杂度，大概是o（n），那么快速幂就是对于这种计算方法的优化，继续拿2的8次方举例，他会判断幂次是奇数还是偶数，发现是偶数，先对底数进行平方，变成4^4，然后继续操作，时间复杂度大概是o（logn）。这为什么能加快速度，其实是因为这样计算减少了计算规模。当然使用这种方法必须让你手写一个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * a % mod; <span class="comment">// 当前位是1</span></span><br><span class="line">        a = a * a % mod;  <span class="comment">// a翻倍</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>; <span class="comment">// 指数右移，相当于除以2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现快速幂首先需要定义一个res，它的作用是存储答案和遇到奇数次幂时乘以底数，比如2^9，res会自乘一个2，然后剩下就变成2的8次方，可以执行我之前说的操作了。</p><hr><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>矩阵快速幂就是标准快速幂的一个拓展，面对矩阵的幂次运算，我们也通过相同的方式，唯一的区别就是底数变成了矩阵，我们需要生成单位矩阵，对矩阵进行赋值等等，原本时间复杂度是o（n^3<em>k），优化后大概是o（n^3</em>log k），其中n是矩阵大小，k是计算次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 矩a阵结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n: 行数, m: 列数</span></span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; a;</span><br><span class="line"><span class="built_in">Matrix</span>(<span class="type">int</span> _n, <span class="type">int</span> _m) : <span class="built_in">n</span>(_n), <span class="built_in">m</span>(_m), <span class="built_in">a</span>(_n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;ll&gt;(_m + <span class="number">1</span>, <span class="number">0</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Matrix <span class="title">identity</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">I</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            I.a[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> I;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 矩阵乘法: C = A * B</span></span><br><span class="line"><span class="comment">// 时间复杂度: O(n^3) 或 O(A.n * A.m * B.m)</span></span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp; A, <span class="type">const</span> Matrix&amp; B) &#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">C</span><span class="params">(A.n, B.m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B.m; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= A.m; ++k) &#123;</span><br><span class="line">                C.a[i][j] = (C.a[i][j] + A.a[i][k] * B.a[k][j]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵快速幂: A^p, 时间复杂度: O(n^3 * log p) , A必须是方阵</span></span><br><span class="line"><span class="function">Matrix <span class="title">power</span><span class="params">(Matrix A, ll p)</span> </span>&#123;</span><br><span class="line">    Matrix res = Matrix::<span class="built_in">identity</span>(A.n);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res= res * A;</span><br><span class="line">            A = A * A;</span><br><span class="line">            p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这些代码最后一部分和标准快速幂相同，就是前面多了定义乘法和结构体部分。</p><hr><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><p>既然我们以及介绍了有关矩阵快速幂的一些知识，后面就可以介绍高斯消元了。线代里高斯消元是通过矩阵多次初等变换来实现的，交换行列位置什么的。总结一下流程，其实就是面对一个方阵，先计算第一列，我们需要找到其中不为0的一项把他那一行提到最高位，并且把那一行归一化处理，后面几行的第一列全部消为0，然后把第二列不为零那一项提到次高位，归一化处理，然后其他全部消为0，以此类推直到结束。那么我们如何用c++来实现这一过程呢？？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss_jordan</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; a, <span class="type">int</span> vars)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> eqs = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (eqs == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; vars &amp;&amp; rk &lt; eqs; ++col) &#123;</span><br><span class="line">        <span class="type">int</span> pivot_row = rk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = rk + <span class="number">1</span>; i &lt; eqs; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i][col]) &gt; <span class="built_in">abs</span>(a[pivot_row][col])) &#123;</span><br><span class="line">                pivot_row = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[rk], a[pivot_row]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(a[rk][col]) &lt; EPS) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> pivot_val = a[rk][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = col; j &lt; a[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            a[rk][j] /= pivot_val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eqs; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != rk) &#123;</span><br><span class="line">                <span class="type">double</span> factor = a[i][col];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = col; j &lt; a[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    a[i][j] -= factor * a[rk][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rk++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码套的最大的一个for循环是为了做之前提到的一列列处理的操作，里面第一个for循环是为了找不为零的那一项，swap一下提到目前应该处理的位置，也就是pivot_row，之后的for循环是归一化处理，接着一个for循环是把其余的几行那几项全部变为0，类推几次就差不多了，不过值得注意的是返回的是矩阵的秩，也就是rk，我们根据rk的值与vars比较，来判断解的个数，vars就是矩阵的行数。</p><table><thead><tr><th>条件</th><th>意义</th></tr></thead><tbody><tr><td>rk &#x3D;&#x3D; vars 且无矛盾</td><td>唯一解</td></tr><tr><td>rk &lt; vars 且无矛盾</td><td>无穷多解（自由变量存在）</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> acm培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2025/07/25/xianduanshu/"/>
      <url>/2025/07/25/xianduanshu/</url>
      
        <content type="html"><![CDATA[<p>线段树的设计是一颗二叉树，用来维护一个序列中各个区间的信息，像什么最大值，最小值，最大公因数等等，因为设计是二叉树，所以时间复杂度大约是（o logn），线段树的精髓是懒标记，懒标记是存储操作的方法，比如我们要在单点修改一个节点，不过操作不会马上进行，会存储在懒标记当中，然后在下次查询的时候执行操作，就可以压缩时间。<br>以下是基本的模板。<br>首先是建立线段树，通过递归建立左树和右数无限二分来实现的，先对叶子节点进行单独处理，然后就是对一般情况递归建立左右树直到遍历到叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    tree[i].l = l;</span><br><span class="line">    tree[i].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[i].val = arr[l]; <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(i*<span class="number">2</span>, l, mid); <span class="comment">//关键递归</span></span><br><span class="line">    <span class="built_in">build</span>(i*<span class="number">2</span><span class="number">+1</span>, mid<span class="number">+1</span>, r); <span class="comment">//关键递归</span></span><br><span class="line">    tree[i].val = tree[i*<span class="number">2</span>].val + tree[i*<span class="number">2</span><span class="number">+1</span>].val; <span class="comment">// 维护区间和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是针对于单点的更新操作，就是修改叶子节点往上推的过程，首先特判叶子节点，让其等于要修改的值，然后通过左右递归找到叶子节点，执行特判，然后通过叶子节点往上反推，计算出每个结点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[i].l == tree[i].r) &#123;</span><br><span class="line">        tree[i].val = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tree[i].l + tree[i].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="built_in">update</span>(i*<span class="number">2</span>, pos, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(i*<span class="number">2</span><span class="number">+1</span>, pos, val);</span><br><span class="line">    tree[i].val = tree[i*<span class="number">2</span>].val + tree[i*<span class="number">2</span><span class="number">+1</span>].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是查询某段区间的值，首先通过类似剪枝的操作，以防遍历一整棵树导致过大的时间复杂度，就是如果树上某个区间小于要查询的区间，就直接返回这段的值。否则就一直往下遍历到条件成立。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r) <span class="keyword">return</span> tree[i].val;</span><br><span class="line">    <span class="type">int</span> mid = (tree[i].l + tree[i].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum += <span class="built_in">query</span>(i*<span class="number">2</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(i*<span class="number">2</span><span class="number">+1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> acm培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp字符匹配算法，字典树，以及ac自动机</title>
      <link href="/2025/07/25/kmp/"/>
      <url>/2025/07/25/kmp/</url>
      
        <content type="html"><![CDATA[<h2 id="kmp字符匹配算法，字典树，以及ac自动机"><a href="#kmp字符匹配算法，字典树，以及ac自动机" class="headerlink" title="kmp字符匹配算法，字典树，以及ac自动机"></a>kmp字符匹配算法，字典树，以及ac自动机</h2><p>最近一直在写匹配问题，其实也没办法，难的自己也不会，只能写点简单的。但有一说一ac自动机是一个很有意思的算法。</p><h3 id="kmp字符匹配算法"><a href="#kmp字符匹配算法" class="headerlink" title="kmp字符匹配算法"></a>kmp字符匹配算法</h3><p>先说kmp的时间复杂度，在给定两个字符串进行匹配的情况下，假设是最坏的情况一位位比较，那么正常两层循环算法的时间复杂度是o（n*m），而kmp算法能讲时间复杂度下降为o（n+m）。<br>这是怎么做到的呢，kmp的原理是什么？比如给定两个字符串，主串是ababcababcac，要匹配的模式串是ababcac。kmp算法要做的就是适当的跳过，前面几位肯定是能吻合的，当匹配到第七位时候不适配了，这时候模式串第二位和主串第七位开始比较，最后得出结论。<br>实现就是通过一个next数组来记录模式串的最大前缀和最大后缀相等的个数，比如对于ababcac，他的next数组是[0, 0, 1, 2, 0, 1, 0]，是在第七位（下标6）不匹配，那么就去看next[6-1&#x3D;5]，发现值是1，接着跳到下标为1的位置，也就是实际第二位开始匹配，循环往复。做个假设，如果跳转后第二位不匹配怎么办？就去找next[1-1&#x3D;0]，有一种迭代的思想在里面。<br>洛谷 p3375模板题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000010</span></span><br><span class="line"><span class="type">int</span> kmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    s1 = <span class="string">&#x27; &#x27;</span> + s1;</span><br><span class="line">    s2 = <span class="string">&#x27; &#x27;</span> + s2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 构建 next 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; s<span class="number">2.l</span>ength(); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s2[j + <span class="number">1</span>] != s2[i]) &#123;</span><br><span class="line">            j = kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s2[i]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        kmp[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s<span class="number">1.l</span>ength(); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s2[j + <span class="number">1</span>] != s1[i]) &#123;</span><br><span class="line">            j = kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s1[i]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == s<span class="number">2.l</span>ength() - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; i - (s<span class="number">2.l</span>ength() - <span class="number">1</span>) + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            j = kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s<span class="number">2.l</span>ength();++i)&#123;</span><br><span class="line">        cout&lt;&lt;kmp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>字典树其实就是把单词每一个字母插入到树当中，如果两个单词拥有相同的前缀，那么他们就共享，就比如ants和apple，a是他们的共享前缀，他有两个子节点（子节点其实就是通过每个节点加一个next指针数组来实现的），也就是度为2，连接着n和p，还有就是在每个单词结尾的那个单词打上一个bool标签表示结束了。这样做的好处就是便于我们去搜索单词库里有没有某个单词，可以试想，有许许多多的单词用着共享前缀，大大节省了空间，又能查询单词，可见这个算法的优越性。这个模板就不写了，和后面ac自动机一起写出来。</p><h3 id="ac自动机"><a href="#ac自动机" class="headerlink" title="ac自动机"></a>ac自动机</h3><p>ac自动机其实就是字典树和kmp算法的结合物，树的构建和字典树一样，然后每个结点，其实就是每个单词还加上了一个fail指针，用处就是匹配失败时候回退到指针指向的位置，重新匹配。考虑字典树中当前的结点 u，u 的父结点是 p，p 通过字符 c 的边指向 u，即 trie(p, c)&#x3D;u。假设深度小于 u 的所有结点的 fail 指针都已求得。<br>1.如果 trie(fail(p), c) 存在：则让 u 的 fail 指针指向 trie(fail(p), c)。相当于在 p 和 fail(p) 后面加一个字符 c，分别对应 u 和 fail(u)；<br>2.如果 trie(fail(p), c) 不存在：那么我们继续找到 trie(fail(fail(p)), c)。重复判断过程，一直跳 fail 指针直到根结点；<br>3.如果依然不存在，就让 fail 指针指向根结点。<br>下面是一个示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ALPHABET = <span class="number">26</span>;  <span class="comment">// 小写英文字母</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[ALPHABET];  <span class="comment">// 子节点指针</span></span><br><span class="line">    <span class="type">int</span> fail;            <span class="comment">// 失败指针</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; output;  <span class="comment">// 匹配到的模式串编号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">-1</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">        fail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Node&gt; <span class="title">trie</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 根节点下标为 0</span></span><br><span class="line">vector&lt;string&gt; patterns;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个模式串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; pattern, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : pattern) &#123;</span><br><span class="line">        <span class="type">int</span> c = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[cur].next[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">            trie[cur].next[c] = trie.<span class="built_in">size</span>();</span><br><span class="line">            trie.<span class="built_in">emplace_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cur = trie[cur].next[c];</span><br><span class="line">    &#125;</span><br><span class="line">    trie[cur].output.<span class="built_in">push_back</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建失败指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; ALPHABET; c++) &#123;</span><br><span class="line">        <span class="type">int</span> nxt = trie[<span class="number">0</span>].next[c];</span><br><span class="line">        <span class="keyword">if</span> (nxt != <span class="number">-1</span>) &#123;</span><br><span class="line">            trie[nxt].fail = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(nxt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            trie[<span class="number">0</span>].next[c] = <span class="number">0</span>;  <span class="comment">// root 自环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; ALPHABET; c++) &#123;</span><br><span class="line">            <span class="type">int</span> v = trie[u].next[c];</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> f = trie[u].fail;</span><br><span class="line">            <span class="keyword">while</span> (trie[f].next[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">                f = trie[f].fail;</span><br><span class="line">            &#125;</span><br><span class="line">            trie[v].fail = trie[f].next[c];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继承 fail 指针的输出结果</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> id : trie[trie[v].fail].output) &#123;</span><br><span class="line">                trie[v].output.<span class="built_in">push_back</span>(id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配主串中的所有位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> c = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (trie[cur].next[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">            cur = trie[cur].fail;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = trie[cur].next[c];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id : trie[cur].output) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;匹配到模式串 #&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; patterns[id]</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; at position &quot;</span> &lt;&lt; i - patterns[id].<span class="built_in">size</span>() + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    patterns = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;she&quot;</span>, <span class="string">&quot;his&quot;</span>, <span class="string">&quot;hers&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; patterns.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(patterns[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line"></span><br><span class="line">    string text = <span class="string">&quot;ushers&quot;</span>;</span><br><span class="line">    <span class="built_in">search</span>(text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，学会ac自动机之后我们就可以搞一些比较好玩的东西出来了，比如现在各大网站都在用的敏感词匹配机制，或者输入法的提示词之类的，本质都是ac自动机的构建。我们可以把海量的词构建成一棵树，然后把想要查询匹配的句子放到这颗树当中，进行匹配，其实挺有意思的。下面就是一个英文匹配代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ALPHABET_SIZE = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    TrieNode* children[ALPHABET_SIZE];</span><br><span class="line">    TrieNode* fail;</span><br><span class="line">    vector&lt;string&gt; output;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        fail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="built_in">sizeof</span>(children));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AhoCorasick</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AhoCorasick</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">AhoCorasick</span>() &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            <span class="type">int</span> idx = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[idx])</span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;output.<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;TrieNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize fail pointers of root&#x27;s children</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;children[i]) &#123;</span><br><span class="line">                root-&gt;children[i]-&gt;fail = root;</span><br><span class="line">                q.<span class="built_in">push</span>(root-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TrieNode* current = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">                TrieNode* child = current-&gt;children[i];</span><br><span class="line">                <span class="keyword">if</span> (!child) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                TrieNode* failNode = current-&gt;fail;</span><br><span class="line">                <span class="keyword">while</span> (failNode &amp;&amp; !failNode-&gt;children[i]) &#123;</span><br><span class="line">                    failNode = failNode-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (failNode)</span><br><span class="line">                    child-&gt;fail = failNode-&gt;children[i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    child-&gt;fail = root;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Merge output links</span></span><br><span class="line">                <span class="keyword">if</span> (child-&gt;fail)</span><br><span class="line">                    child-&gt;output.<span class="built_in">insert</span>(child-&gt;output.<span class="built_in">end</span>(),</span><br><span class="line">                                         child-&gt;fail-&gt;output.<span class="built_in">begin</span>(),</span><br><span class="line">                                         child-&gt;fail-&gt;output.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">                q.<span class="built_in">push</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">query</span><span class="params">(<span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : text) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">islower</span>(ch)) <span class="keyword">continue</span>;  <span class="comment">// skip non-lowercase characters</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> idx = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (node != root &amp;&amp; !node-&gt;children[idx])</span><br><span class="line">                node = node-&gt;fail;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx])</span><br><span class="line">                node = node-&gt;children[idx];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;output.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                result.<span class="built_in">insert</span>(result.<span class="built_in">end</span>(), node-&gt;output.<span class="built_in">begin</span>(), node-&gt;output.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(TrieNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[i]) &#123;</span><br><span class="line">                <span class="built_in">destroy</span>(node-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AhoCorasick ac;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter number of patterns: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter patterns:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        string pattern;</span><br><span class="line">        cin &gt;&gt; pattern;</span><br><span class="line">        <span class="built_in">transform</span>(pattern.<span class="built_in">begin</span>(), pattern.<span class="built_in">end</span>(), pattern.<span class="built_in">begin</span>(), ::tolower); <span class="comment">// optional</span></span><br><span class="line">        ac.<span class="built_in">insert</span>(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">    string text;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter text:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(); <span class="comment">// flush newline</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, text);</span><br><span class="line">    <span class="built_in">transform</span>(text.<span class="built_in">begin</span>(), text.<span class="built_in">end</span>(), text.<span class="built_in">begin</span>(), ::tolower); <span class="comment">// optional</span></span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; matched = ac.<span class="built_in">query</span>(text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matched.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No patterns matched.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Matched patterns:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : matched) &#123;</span><br><span class="line">            cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例输出输入，我就拿无耻之徒里lan和lip的对话举例子了，没办法，这电视剧太能爆粗口了。<br>Enter number of patterns: 5<br>Enter patterns:<br>fuck<br>shit<br>asshole<br>joke<br>stupid<br>Enter text:<br>You must be joking! You’re fucking him?! Him?! He’s married. With kids! What else does he buy you, Ian?” “Listen to me, stupid! You think you know everything, and you don’t know shit…” “Fucking kept boy, at best.” “You smart asshole! Go back there now. Promise Kash you’ll keep your mouth shut… because he’s shitting himself.<br>Matched patterns:<br>fuck<br>stupid<br>shit<br>fuck<br>asshole<br>shit</p>]]></content>
      
      
      
        <tags>
            
            <tag> acm培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针单调栈一些写法</title>
      <link href="/2025/07/25/shungzhizhen/"/>
      <url>/2025/07/25/shungzhizhen/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针单调栈一些写法"><a href="#双指针单调栈一些写法" class="headerlink" title="双指针单调栈一些写法"></a>双指针单调栈一些写法</h2><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>双指针本质其实是对两层for循环的一些优化，我们知道两层循环的时间复杂度大概是在o（n^2），而双指针往往只用了一层遍历就达到了目的，时间复杂度在o（n）。<br>双指针的写法主要依据题目而定，但往往题目对于答案有多个限制要求，标准写法往往是通过for循环或者while循环使右指针有一个从左到右的遍历，然后左指针在满足条件的情况下缩短与右指针的距离。<br>举一个例子。<br>给定一个正整数数组 nums 和一个目标值 s，找到 和 ≥ s 的 最短连续子数组的长度，如果不存在这样的子数组，返回 0。<br>输入：<br>s &#x3D; 7<br>nums &#x3D; [2,3,1,2,4,3]</p><p>输出：<br>2</p><p>解释：<br>子数组 [4,3] 的和是 7，长度为 2，是满足条件的最短子数组。<br>我们不难发现这道题有几个限制要求，一个是 ≥ s 另外一个是最短连续子序列，那么内层循环要做的就是在 ≥ s的情况下缩短子序列长度，下面是示例代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, sum = <span class="number">0</span>, min_len = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; ++right) &#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            min_len = <span class="built_in">min</span>(min_len, right - left + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_len == INT_MAX ? <span class="number">0</span> : min_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈往往解决的问题是数组中每一个数的下一个最大或最小的数，也可以是上一个，通过一个反向遍历，只单调递增或单调递减的栈stack来实现功能。<br>举个例子。给定一个数组 a[]，对于每个位置 i，找出右边第一个比 a[i] 大的元素，返回其下标（没有则为 -1）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>; <span class="comment">// 记录答案，默认都为 -1</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 存下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; a[i] &gt; a[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            ans[st.<span class="built_in">top</span>()] = i;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;右边第一个比 a[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; 大的是 a[&quot;</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是单调栈往往存的是下标，通过一个while循环批量踢出大于或小于每次循环中的a[i]元素，将答案记录在ans数组中输出。</p>]]></content>
      
      
      
        <tags>
            
            <tag> acm培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分三分以及01分数规划</title>
      <link href="/2025/07/25/erfen/"/>
      <url>/2025/07/25/erfen/</url>
      
        <content type="html"><![CDATA[<h2 id="二分三分以及01分数规划"><a href="#二分三分以及01分数规划" class="headerlink" title="二分三分以及01分数规划"></a>二分三分以及01分数规划</h2><h3 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h3><p>二分算法的本质是求严格增或严格减函数，数列，数组中的某一特值，通过将整个区间无限对半开，找到答案所在的区间，经过多次迭代后区间左边界等于区间右边界，或两者无限逼近，那么这个答案就是解。<br>既然知道二分就是对于n个数对半开，那么如果将查询每一个数的时间复杂度视作为单位时间复杂度o（1），二分的时间复杂度就为o（log n），这比在数组中遍历每个元素o（n），快上很多。<br>在一般算法竞赛中或者实际生活中，有时会需要我们去用到二分算法，那么他的标准模板是什么呢？我们如何在c++中运用它呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在二分函数中确定左边界与右边界，通过一个while循环来实现递归的目的，在while中建立一个mid变量，来让他作为新的左右边界来求出答案。<br>手写二分算法往往是很麻烦的事情，不过在c++中，为了求某些特殊情况，c++会给你一些封装的stl来实现。比如你要求数组中最小的元素或者最大的元素，你可以通过lower_bound()或upper_bound()方法来查询，这并不要求数组有序，因为排序的操作是在你使用时候自动进行了，它的时间复杂度也是o（log n）。</p><h3 id="三分算法"><a href="#三分算法" class="headerlink" title="三分算法"></a>三分算法</h3><p>三分算法顾名思义就是把一个数组或区间分为三份，通常用于求凹凸函数的最大值最小值。本质类似与二分，先给出左右端点，再求出两个三等分点，将两个三等分点的函数值进行比较，判断答案处于哪个区间内，然后把其中一个三等分点作为新的端点，进行迭代，求出答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ternarySearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mid1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(mid1) &lt; <span class="built_in">f</span>(mid2))</span><br><span class="line">            r = mid2 - <span class="number">1</span>;  <span class="comment">// 最优解在 [l, mid2-1]</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid1 + <span class="number">1</span>;  <span class="comment">// 最优解在 [mid1+1, r]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i)  <span class="comment">// 最后暴力找出最小</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(i) &lt; <span class="built_in">f</span>(res)) res = i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01分数规划"><a href="#01分数规划" class="headerlink" title="01分数规划"></a>01分数规划</h3><p>题面详见 <a href="https://ac.nowcoder.com/acm/contest/22353/1011">https://ac.nowcoder.com/acm/contest/22353/1011</a><br>这道题是01背包问题的变种，可以用二分去写，思路就是先用结构体定义每个物品，将所求 ∑w&#x2F;∑v&#x3D;r，r要max转化为 ∑w-r*∑v&#x3D;0，找到最大的r。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">item</span>&#123;</span><br><span class="line">    <span class="type">double</span> w,v;</span><br><span class="line">&#125;;</span><br><span class="line">vector &lt;item&gt; items;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> R)</span></span>&#123;</span><br><span class="line">    vector &lt;<span class="type">double</span>&gt; temps;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;items.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        temps.<span class="built_in">push_back</span>(items[i].v-R*items[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(temps.<span class="built_in">rbegin</span>(),temps.<span class="built_in">rend</span>());</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">        sum+=temps[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    items.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;items[i].w&gt;&gt;items[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> left=<span class="number">0</span>;<span class="type">double</span> right=<span class="number">1000001</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;++i)&#123;</span><br><span class="line">        <span class="type">double</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            left=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;left&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> acm培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>siff上影-图像篇</title>
      <link href="/2025/06/18/siff-img/"/>
      <url>/2025/06/18/siff-img/</url>
      
        <content type="html"><![CDATA[<hr><p><img src="/img/siff_1.jpg" alt="艺海剧院"><br><img src="/img/siff_2.jpg" alt="艺海剧院"><br><img src="/img/siff_3.jpg" alt="艺海剧院"><br><img src="/img/siff_4.jpg" alt="艺海剧院"></p><hr><p><img src="/img/siff_5.jpg" alt="天山影院"><br><img src="/img/siff_6.jpg" alt="天山影院"><br><img src="/img/siff_7.jpg" alt="天山影院"><br><img src="/img/siff_8.jpg" alt="天山影院"></p><hr><p><img src="/img/siff_16.jpg" alt="星秩影院"><br><img src="/img/siff_17.jpg" alt="星秩影院"><br><img src="/img/siff_18.jpg" alt="星秩影院"></p><hr><p><img src="/img/siff_9.jpg" alt="通到苏州的11号线"><br><img src="/img/siff_10.jpg" alt="曹杨影院"><br><img src="/img/siff_11.jpg" alt="曹杨影院"><br><img src="/img/siff_12.jpg" alt="曹杨影院"><br><img src="/img/siff_13.jpg" alt="曹杨影院"><br><img src="/img/siff_14.jpg" alt="曹杨影院"><br><img src="/img/siff_15.jpg" alt="曹杨影院"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>siff上影-文字篇</title>
      <link href="/2025/06/18/siff/"/>
      <url>/2025/06/18/siff/</url>
      
        <content type="html"><![CDATA[<h2 id="抢票"><a href="#抢票" class="headerlink" title="抢票"></a>抢票</h2><p>第一次上影体验从抢票开始，想看的电影都抢到了，但与同学缺乏沟通，很多电影位置时间都抢的不好。甚至同学有些抢了多张，我看的四部电影里真正和同学一起看的只有一部，下回真得吸取经验了。</p><h2 id="提前蹲点"><a href="#提前蹲点" class="headerlink" title="提前蹲点"></a>提前蹲点</h2><p>上影的主场在黄浦静安一带，恰好暑期实践活动经过，我们逛了逛大光明，和平影都。大光明里有歪果仁致辞，据说是什么国家驻华大使。我们领了本电影节影迷手册，盖了几个章，挺不错的。</p><h2 id="艺海剧院"><a href="#艺海剧院" class="headerlink" title="艺海剧院"></a>艺海剧院</h2><p>作为上影我要看的第一部电影，电影院的体验感还是很重要的啊。但我看到对艺海的一致差评，真有点后悔选了这。差评不限于类似饮料不能带进去，因为是剧院改电影院，屏幕比较小，二楼座位观感不好云云。<br>到地方看外观其实没什么问题，在艺海领了本电影生活手册，就介绍一下上影节的电影，周边餐饮服务之类的。我选的座位其实比较偏，真有点怕看不清楚屏幕。但实际上进去之后也没那么夸张，由于距离屏幕比较远，所以角度也还好，没有很难受。<br>我看的第一部电影甜蜜蜜，正好又是个剧院改，文艺气氛拉爆了，本身体验感其实很不错。</p><h2 id="星秩STARX影剧院"><a href="#星秩STARX影剧院" class="headerlink" title="星秩STARX影剧院"></a>星秩STARX影剧院</h2><p>开在商场里面的影院，唯一入选上影的宝山电影院，屏幕很大，看着很爽，硬件没什么问题。但商场设计不合理，很多人都找不到电影院。白月光商场把电影院设计在k区2楼，但是k区那边一楼是个停车场，所以如果要上二楼必须从前面abcd区进去上二楼再到k区，就会绕一大圈很麻烦，指示也不明显，很多人都找了好久。<br>这是我唯一一场和同学一起看的，但由于上述客观原因，有一位同学迟到了8分钟，我们少看了八分钟，rnm，退钱！！</p><h2 id="天山电影院——虹桥艺术中心"><a href="#天山电影院——虹桥艺术中心" class="headerlink" title="天山电影院——虹桥艺术中心"></a>天山电影院——虹桥艺术中心</h2><p>天山里面分成两个部分，一个是由于上影剧院改影院，集中在低楼层，还有就是我看的原本就是影院的部分，在五楼。设计和我后面看的曹杨有点像，整体来说中规中矩吧，主要这场电影我有点赶场，也没有细看影院怎么样了。<br>但比较遗憾的是，我认为我在这看的电影是四部里面最烂的，民主的边缘。题材没问题，但是由于纪录片，很多地方拍的比较无趣，同时她都是记录镜头，意思就是这不服务与观众，而服务与真实，很多都很晃，体验感并不好，我中间差点睡着。</p><h2 id="曹杨影城"><a href="#曹杨影城" class="headerlink" title="曹杨影城"></a>曹杨影城</h2><p>综合下来感觉和艺海体验感差不多，曹杨的屏幕是我见过最大，其实就是普通电影院前面那堵墙全部都是屏幕，这场我又抢到了前排，观感更加震撼了。他的影厅在二楼，一楼取票，上影节有些周边也放在二楼卖。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我的第一届上影总体还是很nice的，当然中间有一些不愉快的差距，不过要是说哪个体验感最好，我还是认为是艺海，然后曹杨，星秩，天山。不过所有电影都不及之前在SHO杜比看的ハル，那个真的是神中神。<br>我吃了豆，却并没有昨晚的豆那么好。真的，一直以来，我真的再也没有吃到那夜似的好豆了，——也没有看到那夜似的好戏了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>北洋园 PT</title>
      <link href="/2025/04/22/beiyangyuan/"/>
      <url>/2025/04/22/beiyangyuan/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是北洋园pt？"><a href="#什么是北洋园pt？" class="headerlink" title="什么是北洋园pt？"></a>什么是北洋园pt？</h2><p>在了解北洋园pt之前我们需要去辨析一些名词之间的区别。</p><ol><li>什么是<em><strong>BT</strong></em>？<br>“BT”是“BitTorrent”的缩写，是一种用于在互联网上高效分发文件的协议。与传统的下载方式（如HTTP或FTP）不同，BT采用点对点（P2P）技术，使得每位用户在下载文件的同时，也能将已下载的部分上传给其他用户（做种），从而实现资源的共享和带宽的优化。</li><li>什么是<em><strong>PT</strong></em>？<br>PT(Private Tracker)下载其实也是BT(BitTorrent)下载的一种，是必须拥有一个“帐号”才能下载的BT。其不同于BT的主要特点有：下载量和上传量都会被Tracker服务器记录，而且有做种时间的要求。</li></ol><p><em><strong>北洋园pt是什么？</strong></em><br>北洋园 PT 是一个私有化的资源分享圈子，网站资源以电影、剧集、游戏、动漫、软件为主，资源更新及时迅速。通过上述原理进行资源共享和交换。</p><h2 id="我们该怎么操作"><a href="#我们该怎么操作" class="headerlink" title="我们该怎么操作"></a>我们该怎么操作</h2><h3 id="如何访问？"><a href="#如何访问？" class="headerlink" title="如何访问？"></a>如何访问？</h3><p>网址：<a href="https://tjupt.org/">https://tjupt.org</a><br>访问方式：<br>在校园网环境下（如连接 tjuwlan 或 tjuwlan-lib），可直接访问。<br>使用 IPv6 协议下载或上传资源时，不会消耗校园网套餐流量。<br>在非教育网的互联网环境也可通过 IPv4 协议访问北洋园 PT 网站。</p><h3 id="如何注册？"><a href="#如何注册？" class="headerlink" title="如何注册？"></a>如何注册？</h3><p>拥有天津大学校园邮箱的用户可以自助注册，或者其他学校通过校园网也能注册，<em><strong>仅限高校学生</strong></em>。注册后，通常需要通过“新手考试”或完成相关任务，以确保熟悉站点规则并正确使用 PT 客户端。每个人仅能注册一个账号，绑定的邮箱最好不以edu.cn结尾，以防毕业后无法使用网站。</p><h3 id="用什么软件下载？"><a href="#用什么软件下载？" class="headerlink" title="用什么软件下载？"></a>用什么软件下载？</h3><p>目前北洋园 Tracker 只允许使用以下 BitTorrent 客户端软件的官方发行版本，不允许使用各种非官方修改版客户端、迅雷及各种网盘进行做种和下载。<br>出于稳定性考虑，不会立即支持最新版软件，请不要轻易升级到最新版。</p><p>Windows:</p><ol><li>qBittorrent: 3.<em>.<em>，4.</em>.</em>, 5.0.*（4.2.0-4.2.1、4.5.0-4.5.1存在问题已被禁用，不支持Enhanced增强版）</li><li>uTorrent: 本站推荐使用2.0.4版本，不推荐3.3及后续版本，禁用3.4及后续版本（安装包以及更换版本教程）</li><li>Transmission: 2.*，3.<em>，4.</em></li><li>Deluge: 1.1.6及以上版本</li></ol><p>Linux &amp; Mac OS:</p><ol><li>qBittorrent: 3.<em>.<em>，4.</em>.</em>, 5.0.*（4.2.0-4.2.1、4.5.0-4.5.1存在问题已被禁用，不支持Enhanced增强版）</li><li>Transmission: 2.*，3.*，4.*（4.0.6 版本存在问题已被禁用）</li><li>Deluge: 1.1.6及以上版本</li><li>rtorrent: 0.8.0&#x2F;0.12.0以上</li></ol><p>Mac OS的utorrent for mac对tls1.2的支持不佳，请避免使用。同时请尽量避免使用处于测试期的客户端软件。<br>如果你的客户端不在上面的列表中，你可以使用该客户端下载这个种子。我们将根据分析情况决定是否对该客户端添加支持。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25年蓝桥杯红黑树</title>
      <link href="/2025/04/12/hongheishu/"/>
      <url>/2025/04/12/hongheishu/</url>
      
        <content type="html"><![CDATA[<p>以前听别人忽悠蓝桥杯会dfs暴力就能拿省三，我就赛前突击了一下dfs，没想到25蓝桥杯正好出了红黑树，就记录一下叭~~</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小蓝最近学习了红黑树，红黑树是一种特殊的二叉树，树上的结点有两种类型：红色结点和黑色结点。</p><p>小蓝在脑海中构造出一棵红黑树，构造方式如下：</p><p>根结点是一个红色结点；<br>如果当前结点 curNode 是红色结点，那么左子结点 curNode.left 是红色结点，右子结点 curNode.right 是黑色结点；<br>如果当前结点 curNode 是黑色结点，那么左子结点 curNode.left 是黑色结点，右子结点 curNode.right 是红色结点；<br>此二叉树前几层的形态如下图所示：</p><p>小蓝会从树上随机挑选结点，请你帮忙判断他选出的是红色结点还是黑色结点。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个正整数 m，表示小蓝挑选的结点数。 接下来 m 行，每行包含两个正整数 ni ,ki ，用一个空格分隔，表示小蓝挑选的结点是第 ni （从上往下数）第 ki个（从左往右数）结点。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出 m 行，每行包含一个字符串，依次表示小蓝每次挑选的结点的答案。RED 表示红色结点，BLACK 表示黑色结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span> &amp;&amp; b==<span class="number">1</span>)&#123; <span class="comment">//根结点是一个红色结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(a<span class="number">-1</span>,b%<span class="number">2</span>+b/<span class="number">2</span>)==<span class="number">1</span>)&#123; <span class="comment">//如果当前结点 curNode 是红色结点，</span></span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">1</span>)&#123; <span class="comment">//那么左子结点 curNode.left 是红色结点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//右子结点 curNode.right 是黑色结点；</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,a;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> b; <span class="comment">//根据输入数据得出结论，超过2e5用long long</span></span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(a,b)==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;RED&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;BLACK&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从ishowspeed到iseespeed</title>
      <link href="/2025/03/25/speed/"/>
      <url>/2025/03/25/speed/</url>
      
        <content type="html"><![CDATA[<h2 id="线下真实"><a href="#线下真实" class="headerlink" title="线下真实"></a>线下真实</h2><p>speed来中国了。他准备在中国待两周，去四个地点，上海也来了。春季学期闲得发慌，我和同学直接去面基speed。为此，我们花了30请人代课，翘掉了一节水课，乘地铁去找他。<br><img src="/img/speed_01.jpg"></p><h3 id="人民公园"><a href="#人民公园" class="headerlink" title="人民公园"></a>人民公园</h3><p>他在两点中开直播，我两点半启程出发，同学比我先去一个小时。由于他不会在直播中写清楚地点，我们得从画面里找路标，第一站是人民公园，我同学运气很好，在人民公园碰上他了。但当时我还在地铁上，只能看看他的直播，虽然都是剧本，但节目效果还是很足的。相亲角上有几个被安排上的npc，玩的有点尬。感觉speed来中国大部分都是剧本，还有一些相关的网红来蹭流量，真的纯路人也是有，不多。<br><img src="/img/speed_02.png" alt="相亲角"></p><h3 id="豫园-洛克公园"><a href="#豫园-洛克公园" class="headerlink" title="豫园+洛克公园"></a>豫园+洛克公园</h3><p>他在人民公园呆的时间不长，很快就上车了，我当时乘地铁还没到静安寺，等他在豫园下车我马上转了14号线，本来想着就三站路应该不会时间很长，结果到了站台刚好开走了一班，等了很长时间。speed在豫园街上随便逛了逛，吃了点东西就又上车走了。没办法，又被他跑了，只能先和同学汇合。之后看他去了洛克公园，在里面和王嘉尔玩了会儿。这倒是好机会，我们从地铁站出来就去了洛克公园。听同学说，在人民公园时人不多，可能因为他在洛克公园待得时间长吧，很多粉丝就围在了门口，实在有点恐怖。<br><img src="/img/lkgy_dsr.jpg" alt="都是人啊"><br>当时人实在太多，场面混乱，又被speed跑了。他走了后门，直接上了地下停车场的车，又没蹲到他。我们也不知道他往哪里跑了，又叫来了一个同学，干脆就先把晚饭吃了。吃到一半查出来他在外滩，直接打车去外滩。但没意外的，路上太堵了，等我们到了外滩，他又跑了，真有点无语。本来我们都以为今天可能看不到了，好巧不巧，走在路上看到了他上的双层巴士。他把头探在外面。我第一眼一看，一个黑黑的球，还有两个白白的眼球。我测这不是speed吗，赶紧招呼同学跑上去。之前我还很气地说外滩太堵了，现在只能说是庆幸，小跑两步就追上去了。我看旁边有帽子叔叔，也不敢靠的太近，毕竟车在马路中间吧，就小拍了几张照片，观察了一下国际顶流。他估计连播了好几个小时，有点累,眼神已经有点涣散了。</p><h2 id="整体直播-感受"><a href="#整体直播-感受" class="headerlink" title="整体直播+感受"></a>整体直播+感受</h2><p>很多人都说什么剧本没意思很尬什么的，但实际上如果没有剧本，就像我们平时走在大街上，我觉得这才真的尬，没有人和speed互动，speed一个人自嗨，这才是尬吧。之前看他日本行的直播，确实很尴尬。反观他在欧美，大家都很放得开，有些都不需要什么剧本，这或许就是文化差异，东方文化还是太含蓄了一点。<br><img src="/img/speed2.jpg"><br>还有一些人说什么speed来了一堆人都来跟风，外滩围的人太多，对于治安有很严重影响什么的，所以不应该批准他来什么的。但他来其实是一次宣传，对于中国文化的宣传，这也是government希望的，看他与舞狮，川剧变脸互动，肯定提前安排好了，在相关部门有备案，影响挺不错的，不同文化之间还是多交流比较好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体验上马</title>
      <link href="/2025/02/15/9/"/>
      <url>/2025/02/15/9/</url>
      
        <content type="html"><![CDATA[<p><strong>上马的报名</strong><br>上海马拉松开放报名通道了。我原本没有意愿参加。对于这种专业性很强的运动，我一向把他们置于神圣的位置，在茶余饭后或是食用电子榨菜时感叹一句，真是厉害啊。此外它就和我扯不上多少关系了，报名更是不在考虑范围内。<br>但最终我还是报名了，最初的原因也称不上什么突然开窍，想要挑战一下云云，单纯是同学邀我一起。上海马拉松的健康跑只有六公里，并不算太长，中签率也低，我并没抱有中签的希望。但之后发生的事却让我惊讶，我中签了，我的同学两次抽签都没中。当时心里想的真是天塌了，一个人要去完全陌生的环境跑6公里，这对于我还是一个挑战。<br><strong>上马的准备</strong><br>概括的说，我的赛前练习就是校园跑。现在每每回想就觉得有趣，一个人的处境发生变化，前后对事物的看法也会有翻天覆地的改变。原本我及其厌恶的校园跑，有时甚至以骑车，虚拟ip来作弊的校园跑，成了我每天打卡跑步的动力。开始时跑不下来，每天就只能用四分半的配速跑一公里，渐渐能跑两公里，三公里，再到健康跑的六公里，换作是我报名之前，或许只能感叹一句，真了不起。<br>在开始几天的练习时，我跑法随意，常常不注意体力的分配和呼吸的节奏。往往前五百米是三分配，后五百米是五分配。<br>偶然间一次在跑道遇上一位中长跑运动员，他指导我要三步一吸气，三步一呼气。我接受他的建议后，果然配速上有了提升，这也算是一次不小的收获吧。<br><strong>赛前的准备</strong><br>其实在得知同学没有中签后，我有过不去参赛的想法。以往的经历让我习惯于身边有一名同行的人，但幸运的是，这次也出现了。在比赛前三天，同学告诉我他要去上马看吴向东，这下我们一拍即合，开始赛前行程的安排。<br>由于比赛领取运动服和相关装备定于周六，而比赛正式开始时间是在周日的上午，我们必须在附近定一个酒店。同学给出了36块钱一晚的逆天解决方案。讲实话，这是我住过最便宜的民宿，而且还是在市中心这种地段。如果单纯看大众点评官方的配图，是说的过去的，但真正住进去还是大有不同。<br>之前说领物在周六，具体时间还得由我来定，我选在了周六下午五点，而在这之后正好可以在那边参加一个吴向东的见面会。<br><strong>见面会</strong><br><img src="/img/dkd.jpg" alt="领物"><br>在领完官方配给我的运动服，号码牌之后，我找到同学。我们坐在台阶上，等了三刻钟，等到了吴向东。现场被人堆得水泄不通.<br><img src="/img/wxd.jpg" alt="合上影了"><br>吴向东(会长)是真帅啊，比所谓网图帅多了。现场排了半个小时，一对一合上影了。哈哈哈哈，拍之前我还在嘲笑这样拍照效率低，不如大合照，拍完后马上换了一副嘴脸，一对一合照是真爽啊，体验感算是拉满了。<br><strong>民宿</strong><br>本来不想再写住宿的，但实在太过逆天，六人间的房间住了四个人，整个房间充满了汗味和臭味。民宿不提供毛巾牙刷，只提供枕套，如果一定要说还有什么的话，或许还有一整天糟糕的心情和睡眠。我住在上铺，下铺是一位50多岁的大叔，整个晚上都在打呼噜，居然能自己把自己吵醒，有生之年第一次看到。<br><strong>比赛</strong><br>检录时间是早上五点半，正式开跑时间是七点。得益于极好的住宿体验，我大概半夜三点就忍受不了睡不着了，刷刷手机等到五点和同学一起去检录现场。到现场时候天还没有亮，朦朦胧胧的天也看不到月亮，顶着寒风我在现场站了一个半小时。站着站着天亮了起来，人也渐渐多起来了。现场马拉松选手都开始热身，我也学着做了十分钟。原本冷清的街道慢慢充满了人气，上马把一张张鲜活各异的面孔展现在我面前，或许这种包容就算上海的城市精神吧。<br>七点准时开跑，由于我是健康跑，被分到了起跑位置靠后的区域。所以真正开跑往后推延了十五分钟，现在回想也是一段稀奇的经历，当我从起点起跑的时候，会长已经跑到了健康跑的终点。<br><img src="/img/gc.jpg" alt="跑步中"><br>跑步的过程与我平时校园跑没有多大的变化，但街边的风景到也给我不一样的体验，马路牙子上有很多姑且说是看热闹的市民，为跑者加油助威，这倒是校园跑所没有的。<br>实话实说前三公里是没啥感觉的，跑到后面小腿有些酸痛，后面就五分配慢慢跑了，最后六公里花26分钟也是健康完赛了。<br><img src="/img/zd.jpg" alt="完赛"><br><strong>奖牌</strong><br>哈哈，有一说一这奖牌挺不错的，看样子铁的吧，拿在手上挺沉的，还可以吧。<br><img src="/img/jp.jpg" alt="奖牌"><br><strong>总结</strong><br>健康跑整体的体验是不错的，但是住宿有些让人难以接受，我觉得健康跑的长度倒是有些短，还没有尽兴就结束了，同学并没有跟我跑，一路上有些无聊，下次可以和同学一起跑。<br>写这篇博客拖了很久，24年的事拖到了25年，每每想要写些什么，却总是被其他事所干扰，沉不下心，有点烂尾，也是遗憾吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp动态规划分享</title>
      <link href="/2024/12/29/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E4%BA%AB/"/>
      <url>/2024/12/29/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="dp动态规划分享"><a href="#dp动态规划分享" class="headerlink" title="dp动态规划分享"></a>dp动态规划分享</h2><h3 id="什么是动态规划-？"><a href="#什么是动态规划-？" class="headerlink" title="什么是动态规划 ？"></a>什么是动态规划 ？</h3><p>动态规划（Dynamic Programming，简称DP）是一种算法设计技巧，用于解决具有重叠子问题和最优子结构特性的问题。它是一种将复杂问题分解成更简单的子问题，并通过存储这些子问题的解来避免重复计算的方法。动态规划通常用于优化问题，特别是在计算数学、管理科学、经济学、计算机科学等领域。</p><h3 id="动态规划的核心概念"><a href="#动态规划的核心概念" class="headerlink" title="动态规划的核心概念"></a>动态规划的核心概念</h3><ol><li><p><strong>重叠子问题（Overlapping Subproblems）：</strong> 在递归算法中，相同的子问题被多次解决。例如，在斐波那契数列的递归实现中，Fib(n) 会多次计算 Fib(n-1) 和 Fib(n-2)。动态规划通过存储这些子问题的解来避免重复计算。</p></li><li><p><strong>最优子结构（Optimal Substructure）：</strong> 一个问题的最优解包含其子问题的最优解。例如，在背包问题中，整个背包的最优装载方式可以由各个子背包的最优装载方式组合而成。</p></li><li><p><strong>无后效性（Non-Overlapping Property）：</strong> 一旦某个状态的最优解被确定，它不会受到之后决策的影响。这意味着，对于每个状态，我们只需要考虑如何从之前的状态到达当前状态，而不需要考虑未来的状态。</p></li></ol><h3 id="动态规划的使用"><a href="#动态规划的使用" class="headerlink" title="动态规划的使用"></a>动态规划的使用</h3><ol><li><p><strong>什么时候用DP?</strong><br>当满足<strong>最优子结构</strong>和<strong>无后效性</strong>这两个性质。<br>a. 大问题的最优解可以由小问题的最优解推出，这个性质就叫做“最优子结构”。<br>b. 无后效性指的是在动态规划问题中，一旦某个状态的最优解被确定，它不会受到之后决策的影响。换句话说，对于动态规划中的每个状态，其最优解只依赖于之前的状态，而不依赖于之后的状态。</p></li><li><p><strong>怎么用DP ？</strong><br>a.<strong>状态设计:</strong><br>将原问题划分为若干 阶段，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 状态）<br>b.<strong>状态转移:</strong><br>寻找每一个状态的可能 决策，或者说是各状态间的相互转移方式（用数学的语言描述就是 状态转移方程）。<br>c.<strong>编码实现</strong><br>自顶向下：用带记忆化的递归编码（Top-Down ，先大问题再小问题）</p><p>自下而上：用递推编码（Bottom-Up，先小问题再大问题）</p></li><li><p><strong>斐波那契数列实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">42</span>;            <span class="comment">//因为斐波那契数增长太快，这里只算41个数</span></span><br><span class="line"><span class="type">int</span> dp[N];                  <span class="comment">//记忆结果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span> <span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[n] != <span class="number">0</span>) <span class="keyword">return</span> dp[n];  <span class="comment">//已经计算过，直接返回结果，不再递归</span></span><br><span class="line">    dp[n]= <span class="built_in">fib</span> (n - <span class="number">1</span>) + <span class="built_in">fib</span> (n - <span class="number">2</span>);    <span class="comment">//递归计算，并记忆</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fib</span>(<span class="number">41</span>);       <span class="comment">//计算第41个斐波那契数: 165580141</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/2024/12/25/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/12/25/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown-基础语法"><a href="#markdown-基础语法" class="headerlink" title="markdown 基础语法"></a><em>markdown</em> 基础语法</h1><p>当我们刚开始接触编程时或许并不了解编程语言都有哪些，总是把markdown语法当成一种编程语言，严格意义上其实并不是这样的，那么它究竟是什么，为什么总是被广泛地运用？</p><h2 id="什么是-markdown-语法-？"><a href="#什么是-markdown-语法-？" class="headerlink" title="什么是 markdown 语法 ？"></a>什么是 <em>markdown</em> 语法 ？</h2><p>Markdown 是一种轻量级标记语言，常用于编写文档、格式化文本，尤其是在代码库、博客、论坛等场景下。它语法简单，易于书写和阅读，同时可以转换为HTML等格式，广泛应用于技术文档和说明文件中（例如README文件）。</p><h2 id="我们该如何使用-markdown-语法-？"><a href="#我们该如何使用-markdown-语法-？" class="headerlink" title="我们该如何使用 markdown 语法 ？"></a>我们该如何使用 <em>markdown</em> 语法 ？</h2><hr><h3 id="标题的创建和使用"><a href="#标题的创建和使用" class="headerlink" title="标题的创建和使用"></a>标题的创建和使用</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>标题分为一级标题，二级标题和三级标题，使用时在想要当作标题的文字前打上井号键。</p><table><thead><tr><th>markdown语法</th></tr></thead><tbody><tr><td><code># 这是一级标题 </code></td></tr><tr><td><code>## 这是二级标题 </code></td></tr><tr><td><code>### 这是三级标题 </code></td></tr></tbody></table><p>剩下四级五级标题依此类推即可，我们也可以通过在文字后换行添加任意数量等号来设置一级标题，任意数量—-为二级标题。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>切记在 # 号后添加空格，不然无法达成标题的效果。</p><table><thead><tr><th>✅  Do this</th><th>❌  Don’t do this</th></tr></thead><tbody><tr><td><code># austin我要给你爆金币 </code></td><td><code>#austin我要给你爆金币</code></td></tr></tbody></table><hr><h3 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h3><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p><table><thead><tr><th>markdown语法</th><th>预览效果</th></tr></thead><tbody><tr><td><code>The stars above, a gentle glow,A quiet world where dreams can grow.</code><br><br><code>The breeze that whispers, soft and light,Carries hope into the night.</code></td><td>The stars above, a gentle glow,A quiet world where dreams can grow.<br><br> The breeze that whispers, soft and light,Carries hope into the night.</td></tr></tbody></table><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>我们在使用时并不需要在每一个段落前添加缩进，或者空格。</p><table><thead><tr><th>✅  Do this</th><th>❌  Don’t do this</th></tr></thead><tbody><tr><td><code>The stars above, a gentle glow,A quiet world where dreams can grow.</code><br><br><code>The breeze that whispers, soft and light,Carries hope into the night.</code></td><td>&nbsp;&nbsp;&nbsp;&nbsp;The stars above, a gentle glow,A quiet world where dreams can grow.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;The breeze that whispers, soft and light,Carries hope into the night.</td></tr></tbody></table><hr><h3 id="强调语法"><a href="#强调语法" class="headerlink" title="强调语法"></a>强调语法</h3><h4 id="粗体使用方法"><a href="#粗体使用方法" class="headerlink" title="粗体使用方法"></a>粗体使用方法</h4><p>在使用加粗语法时我们在需要强调的文字周围添加两个*号或者_达成理想的效果。</p><table><thead><tr><th>markdown语法</th><th>预览效果</th></tr></thead><tbody><tr><td><code>you **are** the best </code></td><td>you <strong> are </strong> the best</td></tr><tr><td><code>you __are__  </code></td><td>you <strong> are </strong></td></tr></tbody></table><h4 id="粗体注意事项"><a href="#粗体注意事项" class="headerlink" title="粗体注意事项"></a>粗体注意事项</h4><p>由于各种markdown编译器的不同__的方法并不能很好地适配，因此在句中时尽量使用*号。</p><table><thead><tr><th>✅  Do this</th><th>❌  Don’t do this</th></tr></thead><tbody><tr><td><code>嗨嗨，**austin**我要给你爆金币 </code></td><td><code>嗨嗨，__austin__我要给你爆金币</code></td></tr></tbody></table><h4 id="斜体使用方法"><a href="#斜体使用方法" class="headerlink" title="斜体使用方法"></a>斜体使用方法</h4><p>在使用加粗语法时我们在需要强调的文字周围添加一个*号或者_达成理想的效果，中间不需要带空格。</p><table><thead><tr><th>markdown语法</th><th>预览效果</th></tr></thead><tbody><tr><td><code>you *are* the best </code></td><td>you <em> are </em> the best</td></tr><tr><td><code>you _are_  </code></td><td>you <em> are </em></td></tr></tbody></table><h4 id="两者的同时使用"><a href="#两者的同时使用" class="headerlink" title="两者的同时使用"></a>两者的同时使用</h4><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p><table><thead><tr><th>markdown语法</th><th>预览效果</th></tr></thead><tbody><tr><td><code>you ***are*** the best </code></td><td>you <strong> are </strong> the best</td></tr><tr><td><code>you __are__  </code></td><td>you <strong> are </strong></td></tr></tbody></table><hr><h3 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h3><p>当我们需要引用某句话时，我们需要用引用语法，即在引用语句前加下划线的方式进行引用。<br><code>&gt; 示例</code><br>渲染效果如下所示</p><blockquote><p>示例</p></blockquote><h4 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="多个段落的块引用"></a>多个段落的块引用</h4><p>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1</span><br><span class="line">&gt; 2</span><br><span class="line">&gt; 3</span><br></pre></td></tr></table></figure><p>渲染效果</p><blockquote><p>1<br>2<br>3</p></blockquote><h4 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h4><p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 第一层</span><br><span class="line">&gt;&gt; 第二层1</span><br><span class="line">&gt;&gt; 第二层2</span><br></pre></td></tr></table></figure><p>渲染效果</p><blockquote><p>第一层</p><blockquote><p>第二层1<br>第二层2</p></blockquote></blockquote><h4 id="带有其它元素的块引用"><a href="#带有其它元素的块引用" class="headerlink" title="带有其它元素的块引用"></a>带有其它元素的块引用</h4><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure><p>实际渲染效果如下</p><blockquote><p> The quarterly results look great!</p><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p><ul><li><hr></li></ul></blockquote><h3 id="代码语法"><a href="#代码语法" class="headerlink" title="代码语法"></a>代码语法</h3><h4 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h4><p>我们想要将代码添加到markdown语法中，就必须使用反引号包裹在它的周围。</p><table><thead><tr><th>markdown语法</th><th>预览效果</th></tr></thead><tbody><tr><td>python :<code>`import pandas` </code></td><td>python : <code><code>import pandas</code></code></td></tr></tbody></table><h4 id="转义用法"><a href="#转义用法" class="headerlink" title="转义用法"></a>转义用法</h4><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(&#96;&#96;)中。</p><table><thead><tr><th>markdown语法</th><th>预览效果</th></tr></thead><tbody><tr><td><code>``import `pandas` ``</code></td><td><code>import `pandas` </code></td></tr></tbody></table><h4 id="围栏式代码块"><a href="#围栏式代码块" class="headerlink" title="围栏式代码块"></a>围栏式代码块</h4><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">import pandas</span><br><span class="line">print(&#x27;hello world&#x27;)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>预览效果如下<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pandas</span><br><span class="line">print(&#x27;hello world&#x27;)</span><br></pre></td></tr></table></figure></p></blockquote><hr><h3 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h3><p>插入图片Markdown语法代码：<code> ![图片alt](图片链接)。</code><br>例如 <code>![这是一张示例图](/img/zqs.png)</code><br>渲染效果如下：<br><img src="/img/zqs.png" alt="这是一张示例图"></p><h4 id="给图片增加链接"><a href="#给图片增加链接" class="headerlink" title="给图片增加链接"></a>给图片增加链接</h4><p>给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。<br>例如 <code>[![这是一张示例图](/img/zqs.png)](https://austinnumber2.xin)</code><br>渲染效果如下：<br><a href="https://austinnumber2.xin/"><img src="/img/zqs.png" alt="这是一张示例图"></a></p><hr><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p><code>这是一个链接 [austin blog](https://austinnumber2.xin)。</code><br>实际渲染效果:这是一个链接 <a href="https://austinnumber2.xin/">austin blog</a>。<br>如果我们需要给链接进行一个备注，就在括号内用引号加上备注即可。<br><code>这是一个链接 [austin blog](https://austinnumber2.xin &quot;上大皇帝的blog&quot;)。</code><br>实际渲染效果：<a href="https://austinnumber2.xin/" title="上大皇帝的blog">austin blog</a>。(鼠标放在文字上)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是使用markdown最最基础的语法，对于撰写个人博客来说绰绰有余，markdown本身只是一个传达思想的工具，语法背后的内容是否有价值，我想才是最重要的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 代码分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动抢课脚本的python实现</title>
      <link href="/2024/12/23/3-md/"/>
      <url>/2024/12/23/3-md/</url>
      
        <content type="html"><![CDATA[<h2 id="自动抢课脚本的python实现"><a href="#自动抢课脚本的python实现" class="headerlink" title="自动抢课脚本的python实现"></a>自动抢课脚本的python实现</h2><h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>我们学校的抢课是按照绩点抢课，实际上没有拼手速的需求。但是我的一位在工技大的好友急切地需要抢课的脚本，这也是我写python自动抢课脚本的最大动力。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这并非是我的原创，我是依据同学所创上大抢课脚本改编而成。</p><ol><li>首先我们需要引入<code>selenium</code>和<code>apscheduler</code>两个库来完成网页打开和其中的html解析。通过实例化窗口进入学校抢课的官网，用户在窗口完成登录。</li><li>我通过<code>find_element</code>方法找到选课按钮所在的<code>x_path</code>，运用之前导入的库完成网页的跳转（我们不能直接在一开始就进入选课网页的原因是缺乏了登陆的步骤）。</li><li>之后则如法炮制，我提取课程号和教师号输入框的<code>x_path</code>，通过<code>send_keys</code>方法完成内容的填充，最后提交即可。<br><strong>注：</strong> 由于过快的提交有被ban的风险，因此在每节课输入后适当加入了<code>sleep</code>方法减慢速度，不过总体上对于选课来说依然绰绰有余。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">使用方法：</span></span><br><span class="line"><span class="string">确保安装了selenium和apscheduler,没有安装自行pip</span></span><br><span class="line"><span class="string">在courses_and_teachers中事先填好课程号和教师号，修改start_time</span></span><br><span class="line"><span class="string">注意不要调整窗口大小</span></span><br><span class="line"><span class="string">启动脚本，先登录选好学期，直到进入选课界面为止 然后在控制台按回车（这一步是确认你登录了）</span></span><br><span class="line"><span class="string">控制台说任务已安排，等待即可</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建浏览器实例并设置窗口大小</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.set_window_size(<span class="number">800</span>, <span class="number">900</span>)  <span class="comment"># 设置窗口大小为800x900</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_time = <span class="string">&#x27;2024-12-26 12:50:01&#x27;</span>  <span class="comment"># 设置为你的目标时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill_courses</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 第一节课</span></span><br><span class="line">        <span class="comment"># 使用 XPath 找到按钮</span></span><br><span class="line">        button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;moduleId120446&quot;]/div/tr[3]/td[8]/button/span&#x27;</span>)</span><br><span class="line">        <span class="comment"># 点击按钮</span></span><br><span class="line">        button.click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 填充课程号的输入框</span></span><br><span class="line">        course_input_xpath = <span class="string">f&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[1]/div[2]/input&#x27;</span></span><br><span class="line">        course_input = driver.find_element(By.XPATH, course_input_xpath)</span><br><span class="line">        course_input.clear()</span><br><span class="line">        course_input.send_keys(<span class="string">&#x27;229202&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 填充教师号的输入框</span></span><br><span class="line">        teacher_input_xpath = <span class="string">f&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[2]/div[2]/input&#x27;</span></span><br><span class="line">        teacher_input = driver.find_element(By.XPATH, teacher_input_xpath)</span><br><span class="line">        teacher_input.clear()</span><br><span class="line">        teacher_input.send_keys(<span class="string">&#x27;0597&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 点击第一个查询按钮</span></span><br><span class="line">        first_confirm_button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[16]/button[1]/span&#x27;</span>)</span><br><span class="line">        first_confirm_button.click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 点击第二个确认按钮</span></span><br><span class="line">        second_confirm_button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[3]/div/div[1]/div[3]/table/tbody/tr/td[7]/div/button/span&#x27;</span>)</span><br><span class="line">        second_confirm_button.click()</span><br><span class="line">        </span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            close_button1 = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[4]/div/div[3]/span/button/span&#x27;</span>)</span><br><span class="line">            close_button1.click()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">        close_button2 = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;el-drawer__title&quot;]/button&#x27;</span>)</span><br><span class="line">        close_button2.click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二节课</span></span><br><span class="line">        <span class="comment"># 使用 XPath 找到按钮</span></span><br><span class="line">        button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;moduleId138994&quot;]/div/tr[1]/td[8]/button/span&#x27;</span>)</span><br><span class="line">        <span class="comment"># 点击按钮</span></span><br><span class="line">        button.click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 填充课程号的输入框</span></span><br><span class="line">        course_input_xpath = <span class="string">f&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[1]/div[2]/input&#x27;</span></span><br><span class="line">        course_input = driver.find_element(By.XPATH, course_input_xpath)</span><br><span class="line">        course_input.clear()</span><br><span class="line">        course_input.send_keys(<span class="string">&#x27;180202&#x27;</span>) </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 填充教师号的输入框</span></span><br><span class="line">        teacher_input_xpath = <span class="string">f&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[2]/div[2]/input&#x27;</span></span><br><span class="line">        teacher_input = driver.find_element(By.XPATH, teacher_input_xpath)</span><br><span class="line">        teacher_input.clear()</span><br><span class="line">        teacher_input.send_keys(<span class="string">&#x27;1308&#x27;</span>) <span class="comment">#可修改引号中的课程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 点击第一个查询按钮                                  </span></span><br><span class="line">        first_confirm_button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[16]/button[1]/span&#x27;</span>)</span><br><span class="line">        first_confirm_button.click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 点击第二个确认按钮</span></span><br><span class="line">        second_confirm_button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[3]/div/div[1]/div[3]/table/tbody/tr/td[7]/div/button/span&#x27;</span>)</span><br><span class="line">        second_confirm_button.click()</span><br><span class="line">        </span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            close_button1 = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[4]/div/div[3]/span/button/span&#x27;</span>)</span><br><span class="line">            close_button1.click()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">        close_button2 = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;el-drawer__title&quot;]/button&#x27;</span>)</span><br><span class="line">        close_button2.click()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三节课</span></span><br><span class="line">        <span class="comment"># 使用 XPath 找到按钮</span></span><br><span class="line">        button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;moduleId138994&quot;]/div/tr[2]/td[8]/button/span&#x27;</span>)</span><br><span class="line">        <span class="comment"># 点击按钮</span></span><br><span class="line">        button.click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 填充课程号的输入框</span></span><br><span class="line">        course_input_xpath = <span class="string">f&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[1]/div[2]/input&#x27;</span></span><br><span class="line">        course_input = driver.find_element(By.XPATH, course_input_xpath)</span><br><span class="line">        course_input.clear()</span><br><span class="line">        course_input.send_keys(<span class="string">&#x27;180204&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 填充教师号的输入框</span></span><br><span class="line">        teacher_input_xpath = <span class="string">f&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[2]/div[2]/input&#x27;</span></span><br><span class="line">        teacher_input = driver.find_element(By.XPATH, teacher_input_xpath)</span><br><span class="line">        teacher_input.clear()</span><br><span class="line">        teacher_input.send_keys(<span class="string">&#x27;1633&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 点击第一个查询按钮</span></span><br><span class="line">        first_confirm_button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[16]/button[1]/span&#x27;</span>)</span><br><span class="line">        first_confirm_button.click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 点击第二个确认按钮</span></span><br><span class="line">        second_confirm_button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[3]/div/div[1]/div[3]/table/tbody/tr/td[7]/div/button/span&#x27;</span>)</span><br><span class="line">        second_confirm_button.click()</span><br><span class="line">        </span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            close_button1 = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[4]/div/div[3]/span/button/span&#x27;</span>)</span><br><span class="line">            close_button1.click()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">        close_button2 = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;el-drawer__title&quot;]/button&#x27;</span>)</span><br><span class="line">        close_button2.click()</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第四节课</span></span><br><span class="line">        <span class="comment"># 使用 XPath 找到按钮</span></span><br><span class="line">        button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;moduleId120459&quot;]/div/tr[5]/td[8]/button/span&#x27;</span>)</span><br><span class="line">        <span class="comment"># 点击按钮</span></span><br><span class="line">        button.click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 填充课程号的输入框</span></span><br><span class="line">        course_input_xpath = <span class="string">f&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[1]/div[2]/input&#x27;</span></span><br><span class="line">        course_input = driver.find_element(By.XPATH, course_input_xpath)</span><br><span class="line">        course_input.clear()</span><br><span class="line">        course_input.send_keys(<span class="string">&#x27;219261&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 填充教师号的输入框</span></span><br><span class="line">        teacher_input_xpath = <span class="string">f&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[2]/div[2]/input&#x27;</span></span><br><span class="line">        teacher_input = driver.find_element(By.XPATH, teacher_input_xpath)</span><br><span class="line">        teacher_input.clear()</span><br><span class="line">        teacher_input.send_keys(<span class="string">&#x27;0156&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 点击第一个查询按钮</span></span><br><span class="line">        first_confirm_button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[1]/form/div/div[16]/button[1]/span&#x27;</span>)</span><br><span class="line">        first_confirm_button.click()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 点击第二个确认按钮</span></span><br><span class="line">        second_confirm_button = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[3]/div/div[1]/div[3]/table/tbody/tr/td[7]/div/button/span&#x27;</span>)</span><br><span class="line">        second_confirm_button.click()</span><br><span class="line">       </span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            close_button1 = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;programs&quot;]/div[3]/div[1]/div/div/section/div/div/div/div[4]/div/div[3]/span/button/span&#x27;</span>)</span><br><span class="line">            close_button1.click()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">        close_button2 = driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;el-drawer__title&quot;]/button&#x27;</span>)</span><br><span class="line">        close_button2.click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;出现错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建调度器</span></span><br><span class="line">scheduler = BackgroundScheduler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置定时任务，指定开始时间</span></span><br><span class="line"></span><br><span class="line">scheduler.add_job(fill_courses, <span class="string">&#x27;date&#x27;</span>, run_date=start_time)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 访问目标网页</span></span><br><span class="line">    driver.get(<span class="string">&#x27;https://jxfw.sues.edu.cn/student/home&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请手动登录（在新的标签页中），登录完成后按 Enter 键继续...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待用户手动登录</span></span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&quot;按 Enter 键继续...&quot;</span>)</span><br><span class="line">    scheduler.start()</span><br><span class="line">    <span class="comment"># 等待网页加载</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    driver.get(<span class="string">&#x27;https://jxfw.sues.edu.cn/course-selection/?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJzdXB3aXNkb20iLCJleHAiOjE3MzQ5OTM1MzYsInVzZXJuYW1lIjoiMDI4MTI0NDYxIn0.A_OCgI0vnuc6iKe1LXmee_lrOKoCNycZeWj1HgdNyQI#/course-select/turns&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    driver.get(<span class="string">&#x27;https://jxfw.sues.edu.cn/course-selection/#/course-select/72188805/turn/450/select&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 启动调度器</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务已安排，将在指定时间执行...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保持主线程运行</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 关闭浏览器和调度器</span></span><br><span class="line">    scheduler.shutdown()</span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 代码分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中dfs以及bfs代码分享</title>
      <link href="/2024/12/15/2-md/"/>
      <url>/2024/12/15/2-md/</url>
      
        <content type="html"><![CDATA[<h2 id="c-中dfs以及bfs代码分享"><a href="#c-中dfs以及bfs代码分享" class="headerlink" title="c++中dfs以及bfs代码分享"></a>c++中dfs以及bfs代码分享</h2><h3 id="深度优先搜索（DFS，Depth-First-Search）"><a href="#深度优先搜索（DFS，Depth-First-Search）" class="headerlink" title="深度优先搜索（DFS，Depth-First Search）"></a>深度优先搜索（DFS，Depth-First Search）</h3><p>深度优先搜索（DFS） 是一种遍历或搜索树或图的算法。它的基本思想是从根节点（或任意一个起始节点）开始，沿着一个分支一直走到底（即沿着每条边走到尽头），然后回溯，继续沿其他分支进行搜索，直到遍历完所有节点。</p><p>DFS 的核心特点是“深度优先”，即每次深入到树的子节点，直到没有子节点为止，然后回退到父节点继续搜索。</p><p><strong>基本过程：</strong></p><ol><li>从起始节点开始，首先访问该节点。</li><li>访问该节点的一个未被访问的邻居节点，继续深度遍历。</li><li>直到所有邻居节点都被访问过后，回到上一个节点，继续访问其未被访问的邻居。</li><li>重复上述过程直到遍历完整个图或树。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DFS(Graph, start):</span><br><span class="line">    1. Mark start node as visited</span><br><span class="line">    2. For each neighbor of start:</span><br><span class="line">    3. If the neighbor is not visited, recursively call DFS on it</span><br></pre></td></tr></table></figure><strong>图的表示：</strong><br>图可以使用 邻接矩阵 或 邻接表 来表示。DFS 都可以在这两种结构上实现。<br>DFS 的应用：<br><strong>路径查找：</strong> DFS 可以用于图的路径查找，尤其是在查找所有路径或最深路径时很有效。<br><strong>拓扑排序：</strong> 在有向无环图（DAG）中，DFS 是实现拓扑排序的关键算法。<br><strong>寻找连通分量：</strong> 可以用 DFS 来查找图中所有的连通分量。<br><strong>迷宫问题：</strong> DFS 常用于解决迷宫问题，寻找从起点到终点的路径。<br>图的强连通分量：例如，在求解强连通分量时，可以用 DFS 配合 Tarjan 算法来实现。<br><strong>DFS 算法的时间复杂度：</strong><br>如果使用邻接表表示图，DFS 的时间复杂度是 O(V + E)，其中 V 是节点数，E 是边数。<br>如果使用邻接矩阵表示图，DFS 的时间复杂度是 O(V^2)。<br>示例：用 C++ 实现 DFS<br>以下是一个用 C++ 实现的简单图的 DFS 算法：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印当前节点并标记为已访问</span></span><br><span class="line">    cout &lt;&lt; node &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    visited[node] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归访问所有未访问的邻居节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[node]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(neighbor, graph, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, e;  <span class="comment">// n:节点数, e:边数</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图的邻接表表示</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入图的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        graph[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        graph[v].<span class="built_in">push_back</span>(u);  <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问标记数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 0 开始 DFS</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;DFS Traversal: &quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, graph, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>图的表示：</strong><br>使用邻接表 <code>graph</code> 来存储图的结构。<code>graph[u]</code> 存储与节点 u 相邻的所有节点。</li><li><strong>DFS 函数：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(int node, vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;bool&gt;&amp; visited)：</span><br></pre></td></tr></table></figure>先标记当前节点为已访问。<br>然后递归地访问当前节点的所有未访问过的邻居节点。</li><li><strong>主函数：</strong></li></ol><p>读入图的节点数 n 和边数 e，然后通过输入构造图的邻接表。<br>最后调用 DFS 函数从节点 0 开始遍历图。</p><h3 id="BFS（广度优先搜索）算法介绍"><a href="#BFS（广度优先搜索）算法介绍" class="headerlink" title="BFS（广度优先搜索）算法介绍"></a>BFS（广度优先搜索）算法介绍</h3><p>广度优先搜索（BFS，Breadth-First Search） 是一种用于遍历或搜索图（Graph）或树（Tree）中节点的算法。其基本思想是从一个起始节点开始，沿着图的边逐层访问邻接节点，直到遍历完所有的节点。</p><p><strong>BFS 的核心思想：</strong><br>BFS 是一种 层次遍历 的算法，首先访问起始节点，再访问与之相邻的节点，然后是这些相邻节点的相邻节点，依此类推，逐层访问节点，直到图中所有可达的节点都被访问。</p><p><strong>BFS 的重要特点是：</strong></p><p>逐层访问：它会先访问当前节点的所有邻居，然后再访问它们的邻居，层次逐步加深。<br>最短路径：在无权图中，BFS 可以找到从起点到目标节点的 最短路径。<br><strong>BFS 的基本过程：</strong></p><ol><li><p><strong>初始化：</strong> 从起始节点开始，加入一个 队列（queue），并标记为已访问。创建一个访问标记数组，用来记录哪些节点已经被访问过，防止重复访问。</p></li><li><p><strong>遍历：</strong> 从队列中取出一个节点，访问它，并将所有未被访问过的邻居节点加入队列。对队列中的节点重复上述操作，直到队列为空，说明所有可以到达的节点都已被访问。</p><figure class="highlight plaintext"><figcaption><span>算法步骤（伪代码）：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BFS(Graph, start):</span><br><span class="line">    1. Create a queue Q</span><br><span class="line">    2. Mark start as visited and enqueue start into Q</span><br><span class="line">    3. While Q is not empty:</span><br><span class="line">        a. Dequeue a node from Q</span><br><span class="line">        b. For each neighbor of the node:</span><br><span class="line">            i. If neighbor is not visited:</span><br><span class="line">                - Mark neighbor as visited</span><br><span class="line">                - Enqueue neighbor into Q</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>的图示例：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设我们有以下图结构：</span><br><span class="line"></span><br><span class="line">      A</span><br><span class="line">     / \</span><br><span class="line">    B   C</span><br><span class="line">   / \</span><br><span class="line">  D   E</span><br></pre></td></tr></table></figure><p><strong>BFS 从节点 A 开始遍历：</strong></p></li><li><p>从 A 开始，访问 A。</p></li><li><p>访问 A 的邻居 B 和 C，将它们加入队列。</p></li><li><p>取出 B，访问 B，访问 B 的邻居 D 和 E，将它们加入队列。</p></li><li><p>取出 C，访问 C，但 C 没有新的邻居。</p></li><li><p>取出 D，D 没有新的邻居。</p></li><li><p>取出 E，E 没有新的邻居。</p><div style="text-align: left;">  BFS 的遍历顺序为：A -> B -> C -> D -> E</div></li></ol><p><strong>BFS 算法的实现</strong><br>在实现 BFS 时，我们使用 队列（Queue） 来存储待访问的节点。队列的先进先出（FIFO）特性保证了我们按层次顺序访问节点。</p><figure class="highlight c++"><figcaption><span>实现 BFS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;  <span class="comment">// 访问标记</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;  <span class="comment">// 创建队列</span></span><br><span class="line"></span><br><span class="line">    visited[start] = <span class="literal">true</span>;  <span class="comment">// 标记起始节点为已访问</span></span><br><span class="line">    q.<span class="built_in">push</span>(start);  <span class="comment">// 将起始节点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> node = q.<span class="built_in">front</span>();  <span class="comment">// 取队列头部元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();  <span class="comment">// 弹出队列头部元素</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; node &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 访问当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前节点的所有邻居</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>;  <span class="comment">// 标记为已访问</span></span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);  <span class="comment">// 将邻居节点入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, e;  <span class="comment">// n: 节点数, e: 边数</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; e;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);  <span class="comment">// 图的邻接表表示</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入图的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        graph[u].<span class="built_in">push_back</span>(v);  <span class="comment">// 无向图</span></span><br><span class="line">        graph[v].<span class="built_in">push_back</span>(u);  <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点 0 开始 BFS</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BFS Traversal: &quot;</span>;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">0</span>, graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong><br><strong>邻接表：</strong> 图通过邻接表 graph 来表示，graph[u] 存储与节点 u 相邻的所有节点。<br><strong>队列：</strong> 队列 q 用来存储待访问的节点，先进先出（FIFO）保证了按层次顺序访问节点。<br><strong>访问标记：</strong> visited 数组记录哪些节点已经被访问过，防止重复访问。<br>BFS 遍历：从起始节点 start 开始，先访问它的邻居，再逐层访问其他节点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中差分以及前缀和代码分享</title>
      <link href="/2024/12/09/1-md/"/>
      <url>/2024/12/09/1-md/</url>
      
        <content type="html"><![CDATA[<h2 id="c-中差分以及前缀和代码分享"><a href="#c-中差分以及前缀和代码分享" class="headerlink" title="c++中差分以及前缀和代码分享"></a>c++中差分以及前缀和代码分享</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>前缀和是一种将区间求和问题转化为常数时间查询的技巧。通过预处理一个数组，计算数组中每个元素之前所有元素的和，可以快速进行区间求和。</p><p><strong>前缀和的计算：</strong><br>我们可以通过遍历数组一次来计算前缀和。计算好前缀和数组后，可以在常数时间内查询任意区间的和。<br><strong>前缀和的优势：</strong></p><ol><li><strong>普通的区间求和</strong><br>在没有前缀和技巧时，如果你想求解数组 arr 中一个区间 [l, r] 的和，通常需要通过遍历区间内的元素进行求和。比如，假设我们有一个数组 arr，如果你有多个区间查询（比如查询多个区间的和），那么每次求和都需要遍历一次区间，时间复杂度是<br>𝑂(𝑟−𝑙+1)，如果多次查询的话，总时间复杂度会变得很高。</li><li><strong>前缀和优化</strong><br>前缀和通过预处理一个额外的数组 prefix_sum 来将多次区间求和的复杂度减少到常数时间。prefix_sum[i] 存储的是 arr[0] 到 arr[i-1] 的和。这样，你只需要一次遍历来计算前缀和数组，然后在进行区间查询时，直接通过前缀和数组来获取结果。这种方式的好处是：<br>a. <strong>预处理</strong>：计算前缀和数组的时间复杂度是O(n)，仅需遍历一次数组。<br>b. <strong>查询</strong>：一旦前缀和数组建立起来，任意区间的和查询可以在常数时间 O(1) 内完成。<br>时间复杂度对比：<br><strong>传统方法</strong>：每次区间求和的时间复杂度是 O(r−l+1)，对于多个查询，假设有 q 个查询，最坏情况下时间复杂度是 O(q×n)。<br><strong>前缀和</strong>：前缀和数组的计算时间是 O(n)，每个区间查询的时间复杂度是 O(1)，因此总时间复杂度是 O(n+q)。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 数组</span></span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前缀和数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_sum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 初始化前缀和数组，prefix_sum[0] = 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        prefix_sum[i + <span class="number">1</span>] = prefix_sum[i] + arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; prefix_sum[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询区间和 [l, r]</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">3</span>;  <span class="comment">// 查询区间 [1, 3] 的和</span></span><br><span class="line">    <span class="type">int</span> sum = prefix_sum[r + <span class="number">1</span>] - prefix_sum[l];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;区间 [1, 3] 的和是: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分数组是一种高效地进行区间更新的技巧。通过维护一个差分数组，在区间 [l, r] 上加上一个常数值，可以在常数时间内完成更新。<br><strong>差分数组的定义：</strong><br>假设我们有一个数组 arr，我们可以通过差分数组 diff 来进行快速的区间更新。定义：diff[i]&#x3D;arr[i]−arr<a href="i%3E0">i−1</a><br>这样，差分数组 diff 的累加就是原始数组 arr。<br>差分数组更新：<br>如果我们想在区间 [l, r] 上加上一个常数值 x，我们只需要进行以下两步：<br>将 diff[l] 加上 x。<br>将 diff[r + 1] 减去 x（假设 r + 1 在数组范围内）。<br>最后，通过对差分数组 diff 进行累加，就可以恢复出原始数组 arr。<br><strong>时间复杂度对比</strong>：<br><strong>传统方法</strong>：每次区间更新的时间复杂度是 O(r−l+1)，对于q次更新，最坏情况下时间复杂度是 O(q×n)。<br><strong>差分数组</strong>：每次区间更新的时间复杂度是<br>O(1)，而恢复数组的时间复杂度是 O(n)。因此总时间复杂度是 O(n+q)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 原始数组</span></span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建差分数组，初始化为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diff</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区间更新：[1, 3] 区间加上 2</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">3</span>, x = <span class="number">2</span>;</span><br><span class="line">    diff[l] += x;</span><br><span class="line">    <span class="keyword">if</span> (r + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">        diff[r + <span class="number">1</span>] -= x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过差分数组恢复原数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">new_arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    new_arr[<span class="number">0</span>] = arr[<span class="number">0</span>] + diff[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        new_arr[i] = new_arr[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出更新后的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; new_arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大语言模型的本地部署分享</title>
      <link href="/2024/12/01/ollama/"/>
      <url>/2024/12/01/ollama/</url>
      
        <content type="html"><![CDATA[<h2 id="大语言模型的本地部署分享"><a href="#大语言模型的本地部署分享" class="headerlink" title="大语言模型的本地部署分享"></a>大语言模型的本地部署分享</h2><p>前几天用的梯子过期没续费，直接用不了chatgpt，差点耽误我交作业，因此我想本地部署一个大语言模型，满足我的使用需求</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>能够成功在本地部署大语言模型，实现不通过联网使用的目的。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li><p>下载 <code>ollama</code><br>用魔法进入 <code>ollama</code> 官网 <a href="https://ollama.com/">https://ollama.com/</a> 下载 <code>ollama</code> 启动器，并完成安装。<br><img src="/img/page_1.png"><br>进入cmd，输入<code>ollama</code>来判断是否安装成功。<br><img src="/img/page_2.png"></p></li><li><p>通过 <code>ollama</code> 下载大语言模型<br>进入官网下载大语言模型，由于是个人电脑，推荐选小一点的。比如9b，就是9亿参数，大概五个g。<br><img src="/img/page_3.png"><br>下载完成后我们可以通过命令行调用的方式完成对话，先输入<code>ollama run gemma2</code>,然后对话即可。<br><img src="/img/page_4.png"></p></li><li><p>下载 <code>docker</code>，下载 <code>openwebui</code> 并且部署<br>既然已经可以运行，我们为什么还要下载<code>docker</code>和<code>openwebui</code>呢？因为输入命令行调用的方法太过繁琐，而<code>docker</code>和<code>openwebui</code>能给我们一个整洁的页面，前者可以理解为一个后端，而后者可以理解为前端页面。</p><p>首先我们进入<code>docker</code>下载地址<a href="https://github.com/tech-shrimp/docker_installer">https://github.com/tech-shrimp/docker_installer</a> 在浏览器内打开，我们需要在本地<strong>启用或关闭windows功能</strong>中选择<strong>适用于linux的windows子系统</strong>和<strong>虚拟机平台</strong>，打勾，重启电脑。<br><img src="/img/page_5.png"><br>再通过管理员权限打开cmd，复制以下代码并运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br><span class="line">wsl --update --web-download</span><br></pre></td></tr></table></figure><p><img src="/img/page_6.png"><br>安装完成后进入页面右侧release下载 docker_desktop_installer_windows_x86_64.exe </p><p>并且双击下载完成的 <code>docker</code> 启动器完成docker安装。<br><img src="/img/page_7.png"><br>之后下载 <code>openwebui</code> ，进入网址 <a href="https://github.com/open-webui/open-webui">https://github.com/open-webui/open-webui</a> ，在docker开启的条件下在cmd中运行以下命令</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:8080 --add-host=host.docker.internal:host-gateway -v open-webui:/app/backend/data --name open-webui --restart always ghcr.io/open-webui/open-webui:main</span><br></pre></td></tr></table></figure><p>安装完成后在<code>docker</code>中就能找到端口号进行访问。<br><img src="/img/page_8.png"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 代码分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迪士尼门票计算代码分享</title>
      <link href="/2024/11/26/disney/"/>
      <url>/2024/11/26/disney/</url>
      
        <content type="html"><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p><img src="/img/disney.jpg" alt="题目"><br>根据题目我们可知，我们需要在了解入园观众信息后，对于票价进行计算。反馈给入园观众结果。</p><h3 id="输入要求"><a href="#输入要求" class="headerlink" title="输入要求"></a>输入要求</h3><ol><li><p><strong>出生日期</strong> : 用于计算买票人的年龄。</p></li><li><p><strong>身高</strong> : 用于判断是否有特定优惠(例如儿童)。</p></li><li><p><strong>入园日期</strong> : 用于区分平日或高峰日票价。</p></li><li><p><strong>票的类型</strong> : 包括单日票和两日联票。</p></li></ol><h3 id="票价规则"><a href="#票价规则" class="headerlink" title="票价规则"></a>票价规则</h3><ol><li><strong>平日票价</strong>：<br>成人票：单日票370元，两日连票499元。<br>儿童票（1.4米以下或65岁以上）：单日票280元，两日连票375元。<br>青少年票（1.4米及以上且年龄不满14岁）：单日票280元，两日连票375元。<br>婴幼儿（身高1米及以下）：免费。</li><li><strong>高峰日票价</strong>：<br>成人票：单日票499元，两日连票665元。<br>儿童票（1.4米以下或65岁以上）：单日票375元，两日连票499元。<br>青少年票（1.4米及以上且年龄不满14岁）：单日票375元，两日连票499元。<br>婴幼儿（身高1米及以下）：免费。</li></ol><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下用c++代码实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> birthyear, birthmonth, birthday;</span><br><span class="line">    <span class="type">int</span> enteryear, entermonth, enterday;</span><br><span class="line">    <span class="type">int</span> height, tickettype;</span><br><span class="line">    <span class="type">double</span> baseprice;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入出生年：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; birthyear;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入出生月：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; birthmonth;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入出生日：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; birthday;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入进入园区年份：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; enteryear;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入进入园区月份：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; entermonth;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入进入园区日期：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; enterday;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入身高(cm):&quot;</span>;</span><br><span class="line">    cin &gt;&gt; height;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入票型(1.单日票 2.两日联票):&quot;</span>;</span><br><span class="line">    cin &gt;&gt; tickettype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理基础票价</span></span><br><span class="line">    <span class="keyword">if</span> (enteryear == <span class="number">2016</span> &amp;&amp; entermonth == <span class="number">6</span> &amp;&amp; enterday &gt;= <span class="number">16</span> &amp;&amp; enterday &lt;= <span class="number">30</span>) &#123;</span><br><span class="line">        baseprice = <span class="number">499</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entermonth == <span class="number">7</span> || entermonth == <span class="number">8</span>) &#123;</span><br><span class="line">        baseprice = <span class="number">499</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tm timeStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        timeStruct.tm_year = enteryear - <span class="number">1900</span>;</span><br><span class="line">        timeStruct.tm_mon = entermonth - <span class="number">1</span>;</span><br><span class="line">        timeStruct.tm_mday = enterday;</span><br><span class="line">        <span class="built_in">mktime</span>(&amp;timeStruct);</span><br><span class="line">        <span class="type">int</span> weekday = timeStruct.tm_wday;</span><br><span class="line">        <span class="keyword">if</span> (weekday == <span class="number">0</span> || weekday == <span class="number">6</span>) &#123;</span><br><span class="line">            baseprice = <span class="number">499</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            baseprice = <span class="number">370</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算节假日</span></span><br><span class="line">    <span class="keyword">if</span> (entermonth == <span class="number">10</span> &amp;&amp; enterday &gt;= <span class="number">1</span> &amp;&amp; enterday &lt;= <span class="number">7</span> || entermonth == <span class="number">12</span> &amp;&amp; enterday == <span class="number">27</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        baseprice = <span class="number">499</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entermonth == <span class="number">1</span> &amp;&amp; enterday == <span class="number">1</span> || entermonth == <span class="number">5</span> &amp;&amp; enterday == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        baseprice = <span class="number">499</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entermonth == <span class="number">9</span> &amp;&amp; enterday == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        baseprice = <span class="number">499</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算年龄</span></span><br><span class="line">    <span class="type">double</span> age = enteryear - birthyear + (entermonth - birthmonth) / <span class="number">12.0</span> + (enterday - birthday) / <span class="number">365.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算折扣</span></span><br><span class="line">    <span class="type">double</span> discount1;</span><br><span class="line">    <span class="keyword">if</span> (height &gt; <span class="number">140</span> &amp;&amp; age &lt; <span class="number">65</span>) &#123;</span><br><span class="line">        discount1 = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height &gt; <span class="number">100</span> &amp;&amp; height &lt;= <span class="number">140</span> || age &gt;= <span class="number">65</span>) &#123;</span><br><span class="line">        discount1 = <span class="number">0.75</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        discount1 = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        discount1 = <span class="number">1</span>; <span class="comment">// 默认不打折</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> discount2;</span><br><span class="line">    <span class="keyword">if</span> (tickettype == <span class="number">1</span>) &#123;</span><br><span class="line">        discount2 = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tickettype == <span class="number">2</span>) &#123;</span><br><span class="line">        discount2 = <span class="number">2</span>*<span class="number">0.95</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        discount2 = <span class="number">1</span>; <span class="comment">// 默认票型1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> midprice = discount1 *baseprice;</span><br><span class="line">    <span class="type">double</span> finalprice;</span><br><span class="line">    <span class="keyword">if</span> (midprice &gt;= <span class="number">300</span>)&#123;</span><br><span class="line">        finalprice= discount2 * <span class="number">375</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (midprice ==<span class="number">0</span>)&#123;</span><br><span class="line">        finalprice=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        finalprice= discount2 * <span class="number">280</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最终票价: &quot;</span> &lt;&lt; finalprice &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得写的不错的话可以打赏来支持哦~~<br><img src="/img/%E4%B8%8B%E8%BD%BD1.jpg#pic_left"></p><style>    img[alt='办公室合影']{    max-width: 1%;    }</style>]]></content>
      
      
      
        <tags>
            
            <tag> 代码分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离别是为了更好地相逢</title>
      <link href="/2024/11/23/%E8%A1%8C%E7%9F%A5%E6%9D%AF/"/>
      <url>/2024/11/23/%E8%A1%8C%E7%9F%A5%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<p>借着行知杯决赛的契机，我们回到了高中，看了比赛，也看了老师。那些曾经经历过的岁月与欢乐，在这一刻又重现在我们眼前。我们都说时光就像河流，滚滚向前毫不停歇，然而在某处河流的拐角，我们依然能看到河岸旁自己的身影，连同过往的事迹，被重新记起。<br>高中老师和我们说了很多，有大学生活，有同学的经历，这是我高中毕业后最快乐的时光。老师所讲述的是最稀松平常的事，但我看来却弥足珍贵。</p><p><img src="/img/%E5%8A%9E%E5%85%AC%E5%AE%A4%E5%90%88%E5%BD%B1.jpg" alt="办公室合影"></p><style>    img[alt='办公室合影']{    max-width: 50%;    }</style><p><img src="/img/%E5%8D%95%E6%8B%8D%E5%A5%96%E7%89%8C.jpg" alt="奖牌"><br><img src="/img/%E5%B8%A6%E5%A5%96%E7%89%8C%E4%B8%AA%E4%BA%BA%E7%85%A7.jpg" alt="领奖咯"></p><style>    img[alt='带奖牌个人照']{    max-width: 50%;    }</style><p><img src="/img/%E9%9B%95%E5%83%8F%E5%90%88%E7%85%A7.jpg" alt="雕像前合影"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于博客的一些事</title>
      <link href="/2024/11/21/important/"/>
      <url>/2024/11/21/important/</url>
      
        <content type="html"><![CDATA[<p><strong>这是我一次建立自己的博客，希望在博客上分享自己的生活学习。得益于Sanstale的帮助，使我能够顺利地把博客部署到网站。特此表达感谢之情，也希望大家能去看看他的博客，以下是链接。</strong><br><a href="https://www.cybereal.one/">https://www.cybereal.one/</a></p><style>/* CSS 样式：只针对 #pixel-container 和 .pixel */#pixel-container {    /* 使用 Grid 布局来创建网格 */    display: grid;    /* 边框和阴影 */    border: 2px solid #333;    box-shadow: 0 10px 20px rgba(0,0,0,0.2);    /* 防止在创建时出现闪烁 */    overflow: hidden;     /* 可选：如果在文章中希望居中显示，可以取消下面这行注释 */    /* margin: 30px auto; */}.pixel {    /* 尺寸和颜色由 JavaScript 动态设置，此处留空。 */}</style><div id="pixel-container"></div><script>// --- JavaScript 逻辑：已封装为自执行，无需外部调用 ---// --- 1. 可配置参数 ---// ！！！请替换为您自己的图片 URL！！！const IMAGE_URL_1 = '/img/twt111.jpg';const IMAGE_URL_2 = '/img/twt222.jpg';const GRID_COLS = 50;const GRID_ROWS = 40;const PIXEL_SIZE_PX = 10;const ANIMATION_DURATION_MS = 3000; const PAUSE_DURATION_MS = 10000; // --- 2. 辅助函数 ---function sleep(ms) {    return new Promise(resolve => setTimeout(resolve, ms));}function loadImage(url) {    return new Promise((resolve, reject) => {        const img = new Image();        img.crossOrigin = "Anonymous";         img.onload = () => resolve(img);        img.onerror = reject;        img.src = url;    });}function getImagePixelData(image, cols, rows) {    const canvas = document.createElement('canvas');    const ctx = canvas.getContext('2d');    canvas.width = cols;    canvas.height = rows;    ctx.drawImage(image, 0, 0, cols, rows);    const imageData = ctx.getImageData(0, 0, cols, rows).data;    const colorGrid = [];    let pixelIndex = 0;    for (let y = 0; y < rows; y++) {        const row = [];        for (let x = 0; x < cols; x++) {            const r = imageData[pixelIndex];            const g = imageData[pixelIndex + 1];            const b = imageData[pixelIndex + 2];            const a = imageData[pixelIndex + 3] / 255;             row.push(`rgba(${r}, ${g}, ${b}, ${a})`);            pixelIndex += 4;        }        colorGrid.push(row);    }    return colorGrid;}function createPixelGrid(container, cols, rows, pixelSize) {    container.innerHTML = '';    container.style.gridTemplateColumns = `repeat(${cols}, ${pixelSize}px)`;    container.style.width = `${cols * pixelSize}px`;    container.style.height = `${rows * pixelSize}px`;    const domGrid = [];    for (let y = 0; y < rows; y++) {        const row = [];        for (let x = 0; x < cols; x++) {            const pixel = document.createElement('div');            pixel.className = 'pixel';            pixel.style.width = `${pixelSize}px`;            pixel.style.height = `${pixelSize}px`;            container.appendChild(pixel);            row.push(pixel);        }        domGrid.push(row);    }    return domGrid;}function applyDataToGrid(domGrid, colorData) {    for (let y = 0; y < domGrid.length; y++) {        for (let x = 0; x < domGrid[y].length; x++) {            domGrid[y][x].style.backgroundColor = colorData[y][x];        }    }}// 三次缓动函数：ease-in-out (慢-快-慢)function easeInOutCubic(t) {    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;}// 预处理像素点，按对角线 (x+y) 排序function preprocessPixels(domGrid) {    const pixels = [];    for (let y = 0; y < domGrid.length; y++) {        for (let x = 0; x < domGrid[y].length; x++) {            pixels.push({                pixel: domGrid[y][x],                x: x,                y: y,                diagonalIndex: x + y            });        }    }    pixels.sort((a, b) => a.diagonalIndex - b.diagonalIndex);    return pixels;}// 核心动画函数async function animateDiagonalTransition(sortedPixels, toColorData, duration) {    const startTime = performance.now();    let currentPixelIndex = 0;    const totalPixels = sortedPixels.length;    const maxDiagonalIndex = sortedPixels[totalPixels - 1].diagonalIndex;     return new Promise(resolve => {        function animate() {            const elapsedTime = performance.now() - startTime;            let progress = Math.min(1, elapsedTime / duration);            const easedProgress = easeInOutCubic(progress);            const targetDiagonalIndex = easedProgress * maxDiagonalIndex;             while (currentPixelIndex < totalPixels &&                    sortedPixels[currentPixelIndex].diagonalIndex <= targetDiagonalIndex) {                const pixelInfo = sortedPixels[currentPixelIndex];                pixelInfo.pixel.style.backgroundColor = toColorData[pixelInfo.y][pixelInfo.x];                currentPixelIndex++;            }            if (progress < 1) {                requestAnimationFrame(animate);            } else {                for (let i = currentPixelIndex; i < totalPixels; i++) {                     const pixelInfo = sortedPixels[i];                     pixelInfo.pixel.style.backgroundColor = toColorData[pixelInfo.y][pixelInfo.x];                }                resolve();            }        }        requestAnimationFrame(animate);    });}// --- 3. 主执行函数（自执行）---(async function startPixelAnimation() {const container = document.getElementById('pixel-container');// 如果找不到容器（即在非目标页面），则不执行if (!container) {return;}try {const [img1, img2] = await Promise.all([loadImage(IMAGE_URL_1),loadImage(IMAGE_URL_2)]);const data1 = getImagePixelData(img1, GRID_COLS, GRID_ROWS);const data2 = getImagePixelData(img2, GRID_COLS, GRID_ROWS);const domGrid = createPixelGrid(container, GRID_COLS, GRID_ROWS, PIXEL_SIZE_PX);const sortedPixels = preprocessPixels(domGrid);applyDataToGrid(domGrid, data1);// 开始无限循环while (true) {await sleep(PAUSE_DURATION_MS);await animateDiagonalTransition(sortedPixels, data2, ANIMATION_DURATION_MS);await sleep(PAUSE_DURATION_MS);await animateDiagonalTransition(sortedPixels, data1, ANIMATION_DURATION_MS);}} catch (error) {console.error('像素动画初始化或运行失败:', error);if (container) {container.innerHTML = '动画加载失败。请检查图片 URL 和 CORS 设置。';container.style.color = 'red';container.style.padding = '20px';}}})(); // 立即执行函数</script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
