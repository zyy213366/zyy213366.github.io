<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>kmp字符匹配算法，字典树，以及ac自动机 | austin blog</title><meta name="author" content="austin"><meta name="copyright" content="austin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="kmp字符匹配算法，字典树，以及ac自动机最近一直在写匹配问题，其实也没办法，难的自己也不会，只能写点简单的。但有一说一ac自动机是一个很有意思的算法。 kmp字符匹配算法先说kmp的时间复杂度，在给定两个字符串进行匹配的情况下，假设是最坏的情况一位位比较，那么正常两层循环算法的时间复杂度是o（n*m），而kmp算法能讲时间复杂度下降为o（n+m）。这是怎么做到的呢，kmp的原理是什么？比如给定两">
<meta property="og:type" content="article">
<meta property="og:title" content="kmp字符匹配算法，字典树，以及ac自动机">
<meta property="og:url" content="https://zyy213366.github.io/2025/07/25/kmp/index.html">
<meta property="og:site_name" content="austin blog">
<meta property="og:description" content="kmp字符匹配算法，字典树，以及ac自动机最近一直在写匹配问题，其实也没办法，难的自己也不会，只能写点简单的。但有一说一ac自动机是一个很有意思的算法。 kmp字符匹配算法先说kmp的时间复杂度，在给定两个字符串进行匹配的情况下，假设是最坏的情况一位位比较，那么正常两层循环算法的时间复杂度是o（n*m），而kmp算法能讲时间复杂度下降为o（n+m）。这是怎么做到的呢，kmp的原理是什么？比如给定两">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zyy213366.github.io/img/02.jpg">
<meta property="article:published_time" content="2025-07-25T05:51:08.000Z">
<meta property="article:modified_time" content="2025-07-25T07:27:27.420Z">
<meta property="article:author" content="austin">
<meta property="article:tag" content="acm培训">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zyy213366.github.io/img/02.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zyy213366.github.io/2025/07/25/kmp/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kmp字符匹配算法，字典树，以及ac自动机',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/02.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/%E4%B8%8B%E8%BD%BD1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">austin blog</span></a><a class="nav-page-title" href="/"><span class="site-name">kmp字符匹配算法，字典树，以及ac自动机</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">kmp字符匹配算法，字典树，以及ac自动机</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-25T05:51:08.000Z" title="发表于 2025-07-25 13:51:08">2025-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-25T07:27:27.420Z" title="更新于 2025-07-25 15:27:27">2025-07-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="kmp字符匹配算法，字典树，以及ac自动机"><a href="#kmp字符匹配算法，字典树，以及ac自动机" class="headerlink" title="kmp字符匹配算法，字典树，以及ac自动机"></a>kmp字符匹配算法，字典树，以及ac自动机</h2><p>最近一直在写匹配问题，其实也没办法，难的自己也不会，只能写点简单的。但有一说一ac自动机是一个很有意思的算法。</p>
<h3 id="kmp字符匹配算法"><a href="#kmp字符匹配算法" class="headerlink" title="kmp字符匹配算法"></a>kmp字符匹配算法</h3><p>先说kmp的时间复杂度，在给定两个字符串进行匹配的情况下，假设是最坏的情况一位位比较，那么正常两层循环算法的时间复杂度是o（n*m），而kmp算法能讲时间复杂度下降为o（n+m）。<br>这是怎么做到的呢，kmp的原理是什么？比如给定两个字符串，主串是ababcababcac，要匹配的模式串是ababcac。kmp算法要做的就是适当的跳过，前面几位肯定是能吻合的，当匹配到第七位时候不适配了，这时候模式串第二位和主串第七位开始比较，最后得出结论。<br>实现就是通过一个next数组来记录模式串的最大前缀和最大后缀相等的个数，比如对于ababcac，他的next数组是[0, 0, 1, 2, 0, 1, 0]，是在第七位（下标6）不匹配，那么就去看next[6-1&#x3D;5]，发现值是1，接着跳到下标为1的位置，也就是实际第二位开始匹配，循环往复。做个假设，如果跳转后第二位不匹配怎么办？就去找next[1-1&#x3D;0]，有一种迭代的思想在里面。<br>洛谷 p3375模板题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000010</span></span><br><span class="line"><span class="type">int</span> kmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    s1 = <span class="string">&#x27; &#x27;</span> + s1;</span><br><span class="line">    s2 = <span class="string">&#x27; &#x27;</span> + s2;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 构建 next 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; s<span class="number">2.l</span>ength(); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s2[j + <span class="number">1</span>] != s2[i]) &#123;</span><br><span class="line">            j = kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s2[i]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        kmp[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s<span class="number">1.l</span>ength(); ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s2[j + <span class="number">1</span>] != s1[i]) &#123;</span><br><span class="line">            j = kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s1[i]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == s<span class="number">2.l</span>ength() - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; i - (s<span class="number">2.l</span>ength() - <span class="number">1</span>) + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            j = kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s<span class="number">2.l</span>ength();++i)&#123;</span><br><span class="line">        cout&lt;&lt;kmp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>字典树其实就是把单词每一个字母插入到树当中，如果两个单词拥有相同的前缀，那么他们就共享，就比如ants和apple，a是他们的共享前缀，他有两个子节点（子节点其实就是通过每个节点加一个next指针数组来实现的），也就是度为2，连接着n和p，还有就是在每个单词结尾的那个单词打上一个bool标签表示结束了。这样做的好处就是便于我们去搜索单词库里有没有某个单词，可以试想，有许许多多的单词用着共享前缀，大大节省了空间，又能查询单词，可见这个算法的优越性。这个模板就不写了，和后面ac自动机一起写出来。</p>
<h3 id="ac自动机"><a href="#ac自动机" class="headerlink" title="ac自动机"></a>ac自动机</h3><p>ac自动机其实就是字典树和kmp算法的结合物，树的构建和字典树一样，然后每个结点，其实就是每个单词还加上了一个fail指针，用处就是匹配失败时候回退到指针指向的位置，重新匹配。考虑字典树中当前的结点 u，u 的父结点是 p，p 通过字符 c 的边指向 u，即 trie(p, c)&#x3D;u。假设深度小于 u 的所有结点的 fail 指针都已求得。<br>1.如果 trie(fail(p), c) 存在：则让 u 的 fail 指针指向 trie(fail(p), c)。相当于在 p 和 fail(p) 后面加一个字符 c，分别对应 u 和 fail(u)；<br>2.如果 trie(fail(p), c) 不存在：那么我们继续找到 trie(fail(fail(p)), c)。重复判断过程，一直跳 fail 指针直到根结点；<br>3.如果依然不存在，就让 fail 指针指向根结点。<br>下面是一个示例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ALPHABET = <span class="number">26</span>;  <span class="comment">// 小写英文字母</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> next[ALPHABET];  <span class="comment">// 子节点指针</span></span><br><span class="line">    <span class="type">int</span> fail;            <span class="comment">// 失败指针</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; output;  <span class="comment">// 匹配到的模式串编号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">-1</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">        fail = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Node&gt; <span class="title">trie</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 根节点下标为 0</span></span><br><span class="line">vector&lt;string&gt; patterns;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个模式串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; pattern, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : pattern) &#123;</span><br><span class="line">        <span class="type">int</span> c = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[cur].next[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">            trie[cur].next[c] = trie.<span class="built_in">size</span>();</span><br><span class="line">            trie.<span class="built_in">emplace_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cur = trie[cur].next[c];</span><br><span class="line">    &#125;</span><br><span class="line">    trie[cur].output.<span class="built_in">push_back</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建失败指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; ALPHABET; c++) &#123;</span><br><span class="line">        <span class="type">int</span> nxt = trie[<span class="number">0</span>].next[c];</span><br><span class="line">        <span class="keyword">if</span> (nxt != <span class="number">-1</span>) &#123;</span><br><span class="line">            trie[nxt].fail = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(nxt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            trie[<span class="number">0</span>].next[c] = <span class="number">0</span>;  <span class="comment">// root 自环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; ALPHABET; c++) &#123;</span><br><span class="line">            <span class="type">int</span> v = trie[u].next[c];</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> f = trie[u].fail;</span><br><span class="line">            <span class="keyword">while</span> (trie[f].next[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">                f = trie[f].fail;</span><br><span class="line">            &#125;</span><br><span class="line">            trie[v].fail = trie[f].next[c];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继承 fail 指针的输出结果</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> id : trie[trie[v].fail].output) &#123;</span><br><span class="line">                trie[v].output.<span class="built_in">push_back</span>(id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配主串中的所有位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> c = text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (trie[cur].next[c] == <span class="number">-1</span>) &#123;</span><br><span class="line">            cur = trie[cur].fail;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = trie[cur].next[c];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> id : trie[cur].output) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;匹配到模式串 #&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; patterns[id]</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; at position &quot;</span> &lt;&lt; i - patterns[id].<span class="built_in">size</span>() + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例用法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    patterns = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;she&quot;</span>, <span class="string">&quot;his&quot;</span>, <span class="string">&quot;hers&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; patterns.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(patterns[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line"></span><br><span class="line">    string text = <span class="string">&quot;ushers&quot;</span>;</span><br><span class="line">    <span class="built_in">search</span>(text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，学会ac自动机之后我们就可以搞一些比较好玩的东西出来了，比如现在各大网站都在用的敏感词匹配机制，或者输入法的提示词之类的，本质都是ac自动机的构建。我们可以把海量的词构建成一棵树，然后把想要查询匹配的句子放到这颗树当中，进行匹配，其实挺有意思的。下面就是一个英文匹配代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ALPHABET_SIZE = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    TrieNode* children[ALPHABET_SIZE];</span><br><span class="line">    TrieNode* fail;</span><br><span class="line">    vector&lt;string&gt; output;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        fail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="built_in">sizeof</span>(children));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AhoCorasick</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AhoCorasick</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">AhoCorasick</span>() &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            <span class="type">int</span> idx = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[idx])</span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;output.<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue&lt;TrieNode*&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize fail pointers of root&#x27;s children</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;children[i]) &#123;</span><br><span class="line">                root-&gt;children[i]-&gt;fail = root;</span><br><span class="line">                q.<span class="built_in">push</span>(root-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TrieNode* current = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">                TrieNode* child = current-&gt;children[i];</span><br><span class="line">                <span class="keyword">if</span> (!child) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                TrieNode* failNode = current-&gt;fail;</span><br><span class="line">                <span class="keyword">while</span> (failNode &amp;&amp; !failNode-&gt;children[i]) &#123;</span><br><span class="line">                    failNode = failNode-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (failNode)</span><br><span class="line">                    child-&gt;fail = failNode-&gt;children[i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    child-&gt;fail = root;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Merge output links</span></span><br><span class="line">                <span class="keyword">if</span> (child-&gt;fail)</span><br><span class="line">                    child-&gt;output.<span class="built_in">insert</span>(child-&gt;output.<span class="built_in">end</span>(),</span><br><span class="line">                                         child-&gt;fail-&gt;output.<span class="built_in">begin</span>(),</span><br><span class="line">                                         child-&gt;fail-&gt;output.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">                q.<span class="built_in">push</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">query</span><span class="params">(<span class="type">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : text) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">islower</span>(ch)) <span class="keyword">continue</span>;  <span class="comment">// skip non-lowercase characters</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> idx = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (node != root &amp;&amp; !node-&gt;children[idx])</span><br><span class="line">                node = node-&gt;fail;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx])</span><br><span class="line">                node = node-&gt;children[idx];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;output.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                result.<span class="built_in">insert</span>(result.<span class="built_in">end</span>(), node-&gt;output.<span class="built_in">begin</span>(), node-&gt;output.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(TrieNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ALPHABET_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[i]) &#123;</span><br><span class="line">                <span class="built_in">destroy</span>(node-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AhoCorasick ac;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter number of patterns: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter patterns:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        string pattern;</span><br><span class="line">        cin &gt;&gt; pattern;</span><br><span class="line">        <span class="built_in">transform</span>(pattern.<span class="built_in">begin</span>(), pattern.<span class="built_in">end</span>(), pattern.<span class="built_in">begin</span>(), ::tolower); <span class="comment">// optional</span></span><br><span class="line">        ac.<span class="built_in">insert</span>(pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">    string text;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter text:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(); <span class="comment">// flush newline</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, text);</span><br><span class="line">    <span class="built_in">transform</span>(text.<span class="built_in">begin</span>(), text.<span class="built_in">end</span>(), text.<span class="built_in">begin</span>(), ::tolower); <span class="comment">// optional</span></span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; matched = ac.<span class="built_in">query</span>(text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matched.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No patterns matched.\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Matched patterns:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> string&amp; word : matched) &#123;</span><br><span class="line">            cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例输出输入，我就拿无耻之徒里lan和lip的对话举例子了，没办法，这电视剧太能爆粗口了。<br>Enter number of patterns: 5<br>Enter patterns:<br>fuck<br>shit<br>asshole<br>joke<br>stupid<br>Enter text:<br>You must be joking! You’re fucking him?! Him?! He’s married. With kids! What else does he buy you, Ian?” “Listen to me, stupid! You think you know everything, and you don’t know shit…” “Fucking kept boy, at best.” “You smart asshole! Go back there now. Promise Kash you’ll keep your mouth shut… because he’s shitting himself.<br>Matched patterns:<br>fuck<br>stupid<br>shit<br>fuck<br>asshole<br>shit</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zyy213366.github.io">austin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zyy213366.github.io/2025/07/25/kmp/">https://zyy213366.github.io/2025/07/25/kmp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zyy213366.github.io" target="_blank">austin blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/acm%E5%9F%B9%E8%AE%AD/">acm培训</a></div><div class="post-share"><div class="social-share" data-image="/img/02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/pay.jpg" alt="微信支付"/></a><div class="post-qr-code-desc">微信支付</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/25/xianduanshu/" title="线段树"><img class="cover" src="/img/02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">线段树</div></div><div class="info-2"><div class="info-item-1">线段树的设计是一颗二叉树，用来维护一个序列中各个区间的信息，像什么最大值，最小值，最大公因数等等，因为设计是二叉树，所以时间复杂度大约是（o logn），线段树的精髓是懒标记，懒标记是存储操作的方法，比如我们要在单点修改一个节点，不过操作不会马上进行，会存储在懒标记当中，然后在下次查询的时候执行操作，就可以压缩时间。以下是基本的模板。首先是建立线段树，通过递归建立左树和右数无限二分来实现的，先对叶子节点进行单独处理，然后就是对一般情况递归建立左右树直到遍历到叶子节点。 12345678910111213void build(int i, int l, int r) &#123;    tree[i].l = l;    tree[i].r = r;    if (l == r) &#123;        tree[i].val = arr[l]; // 叶子节点        return;    &#125;    int mid = (l + r) / 2;    build(i*2, l, mid); //关键递归    build(i*2+1, mid+1, r);...</div></div></div></a><a class="pagination-related" href="/2025/07/25/shungzhizhen/" title="双指针单调栈一些写法"><img class="cover" src="/img/02.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">双指针单调栈一些写法</div></div><div class="info-2"><div class="info-item-1">双指针单调栈一些写法双指针双指针本质其实是对两层for循环的一些优化，我们知道两层循环的时间复杂度大概是在o（n^2），而双指针往往只用了一层遍历就达到了目的，时间复杂度在o（n）。双指针的写法主要依据题目而定，但往往题目对于答案有多个限制要求，标准写法往往是通过for循环或者while循环使右指针有一个从左到右的遍历，然后左指针在满足条件的情况下缩短与右指针的距离。举一个例子。给定一个正整数数组 nums 和一个目标值 s，找到 和 ≥ s 的 最短连续子数组的长度，如果不存在这样的子数组，返回 0。输入：s &#x3D; 7nums &#x3D; [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 的和是 7，长度为 2，是满足条件的最短子数组。我们不难发现这道题有几个限制要求，一个是 ≥ s 另外一个是最短连续子序列，那么内层循环要做的就是在 ≥ s的情况下缩短子序列长度，下面是示例代码。 12345678910111213141516int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;  ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/06/boyilun/" title="博弈论的一些很基础知识"><img class="cover" src="/img/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-06</div><div class="info-item-2">博弈论的一些很基础知识</div></div><div class="info-2"><div class="info-item-1">公平组合游戏公平组合游戏是两个人进行的游戏，回合制并且每个人操作的对象是同一个，换言之每一步状态，怎么操作都与操作者无关，两人都是全知全能，进行每一步操作时都了解后面操作的所有状态，去选择对自己最有利的解，这就叫做公平组合游戏，而基础的博弈论就是探讨这种情况的。 博弈论中最基本的知识在进行公平组合游戏时，每一步的状态可以概括为两种。p态：后手必胜，即这个回合开始时操作者的对手一定会赢。n态：先手必胜，即这个回合开始时操作者一定会赢。知道这两个概念之后不难推出两个结论。  能变成p态的状态一定是n态。因为每个人都想要最优解，如果前面已经先手必胜，那么等于可以选择下一回合自己变成后手必胜。当然也可以不选，那么就会输。 p态只能变成n态。这个回合我是后手必胜的状态，无法操作，但由于是必胜的状态，下一回合我操作一定是先手必胜。  sg函数sg函数是决定谁胜谁败的关键。我们规定sg函数的公式为 g(x)&#x3D;mex{g(y)}...</div></div></div></a><a class="pagination-related" href="/2025/08/07/deque/" title="并查集，优先队列，双端队列"><img class="cover" src="/img/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-07</div><div class="info-item-2">并查集，优先队列，双端队列</div></div><div class="info-2"><div class="info-item-1">并查集当我们碰到堆的划分问题时候我们可以用到并查集，其实就是每个节点通过一个父节点来存储信息，然后通过递归的方法将一个堆中所有子节点或叶子节点的父节点全部指向根节点，而根节点的父节点指向自己。本来我没有了解到这一层的时候认为堆的合并将会是很困难的事，因为每个父节点是不一样的，但现在就好办了，我们只要把两个根节点给合并，最后再递归一下就算成功了。它的时间复杂度比o（log n）很快，是反阿克曼函数，接近于o（1）。 12345678910int find_set(int i) &#123;    if (fa[i] == i) return i;    return fa[i] = find_set(fa[i]);&#125;void union_set(int a, int b) &#123;    a = find_set(a);    b = find_set(b);    if (a != b) fa[b] =...</div></div></div></a><a class="pagination-related" href="/2025/08/04/gauss/" title="高斯消元，快速幂和一些拓展"><img class="cover" src="/img/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-04</div><div class="info-item-2">高斯消元，快速幂和一些拓展</div></div><div class="info-2"><div class="info-item-1">标准快速幂平时计算幂次时计算机的一般方法其实就是累乘，比如2^8就是222*2一直乘下去，这带来了极高的时间复杂度，大概是o（n），那么快速幂就是对于这种计算方法的优化，继续拿2的8次方举例，他会判断幂次是奇数还是偶数，发现是偶数，先对底数进行平方，变成4^4，然后继续操作，时间复杂度大概是o（logn）。这为什么能加快速度，其实是因为这样计算减少了计算规模。当然使用这种方法必须让你手写一个函数。 123456789long long qpow(long long a, long long n, long long mod) &#123;    long long res = 1;    while (n &gt; 0) &#123;        if (n &amp; 1) res = res * a % mod; // 当前位是1        a = a * a % mod;  // a翻倍        n &gt;&gt;= 1; // 指数右移，相当于除以2    &#125;    return...</div></div></div></a><a class="pagination-related" href="/2025/08/14/hash/" title="哈希表"><img class="cover" src="/img/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-14</div><div class="info-item-2">哈希表</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/07/25/erfen/" title="二分三分以及01分数规划"><img class="cover" src="/img/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-25</div><div class="info-item-2">二分三分以及01分数规划</div></div><div class="info-2"><div class="info-item-1">二分三分以及01分数规划二分算法二分算法的本质是求严格增或严格减函数，数列，数组中的某一特值，通过将整个区间无限对半开，找到答案所在的区间，经过多次迭代后区间左边界等于区间右边界，或两者无限逼近，那么这个答案就是解。既然知道二分就是对于n个数对半开，那么如果将查询每一个数的时间复杂度视作为单位时间复杂度o（1），二分的时间复杂度就为o（log n），这比在数组中遍历每个元素o（n），快上很多。在一般算法竞赛中或者实际生活中，有时会需要我们去用到二分算法，那么他的标准模板是什么呢？我们如何在c++中运用它呢？ 12345678910int binarySearch(vector&lt;int&gt;&amp; a, int target) &#123;    int l = 0, r = a.size() - 1;    while (l &lt;= r) &#123;        int mid = (l + r) / 2;        if (a[mid] == target) return mid;        else if (a[mid] &lt; target)...</div></div></div></a><a class="pagination-related" href="/2025/08/04/oujilide/" title="欧几里得的游戏"><img class="cover" src="/img/02.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-04</div><div class="info-item-2">欧几里得的游戏</div></div><div class="info-2"><div class="info-item-1">本来我是完全没有接触过博弈论的，但是今天看到了这道题，用到了Euclidean Game 定理。搜了一下，发现这玩意好像有点意思，就写一下。 题干欧几里德的两个后代 Stan 和 Ollie 正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数 M 和 N，从 Stan 开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于 0 。然后是 Ollie，对刚才得到的数，和 M , N 中较小的那个数，再进行同样的操作……直到一个人得到了0，他就取得了胜利。下面是他们用(25,7) 两个数游戏的过程： 初始：(25,7)；Stan：(11,7)；Ollie：(4,7)；Stan：(4,3)；Ollie：(1,3)；Stan：(1,0)。Stan 赢得了游戏的胜利。 现在，假设他们完美地操作，谁会取得胜利呢？ Input本题有多组测试数据。第一行为测试数据的组数 C 。 下面 C 行，每行为一组数据，包含两个正整数 M , N(M , N&lt;2^31)M,N(M,N&lt;2^31)。 Output对每组输入数据输出一行，如果 Stan...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/%E4%B8%8B%E8%BD%BD1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">austin</div><div class="author-info-description">an interesting soul</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zyy213366/zyy213366.github.io"><i class="fab fa-github"></i><span>请关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.youtube.com/" target="_blank" title="youtube"><i class="fa-brands fa-youtube"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是austin的博客，austin会在上面分享自己经历的有趣的事~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#kmp%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%8C%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%8C%E4%BB%A5%E5%8F%8Aac%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.</span> <span class="toc-text">kmp字符匹配算法，字典树，以及ac自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kmp%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">kmp字符匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">1.2.</span> <span class="toc-text">字典树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ac%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">ac自动机</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/09/19/diankongzuoye/" title="行知防空洞"><img src="/img/02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行知防空洞"/></a><div class="content"><a class="title" href="/2025/09/19/diankongzuoye/" title="行知防空洞">行知防空洞</a><time datetime="2025-09-19T11:44:59.000Z" title="发表于 2025-09-19 19:44:59">2025-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/14/hash/" title="哈希表"><img src="/img/02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="哈希表"/></a><div class="content"><a class="title" href="/2025/08/14/hash/" title="哈希表">哈希表</a><time datetime="2025-08-14T03:27:06.000Z" title="发表于 2025-08-14 11:27:06">2025-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/07/deque/" title="并查集，优先队列，双端队列"><img src="/img/02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并查集，优先队列，双端队列"/></a><div class="content"><a class="title" href="/2025/08/07/deque/" title="并查集，优先队列，双端队列">并查集，优先队列，双端队列</a><time datetime="2025-08-07T08:07:06.000Z" title="发表于 2025-08-07 16:07:06">2025-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/06/boyilun/" title="博弈论的一些很基础知识"><img src="/img/02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博弈论的一些很基础知识"/></a><div class="content"><a class="title" href="/2025/08/06/boyilun/" title="博弈论的一些很基础知识">博弈论的一些很基础知识</a><time datetime="2025-08-06T12:19:23.000Z" title="发表于 2025-08-06 20:19:23">2025-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/04/oujilide/" title="欧几里得的游戏"><img src="/img/02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="欧几里得的游戏"/></a><div class="content"><a class="title" href="/2025/08/04/oujilide/" title="欧几里得的游戏">欧几里得的游戏</a><time datetime="2025-08-04T08:11:04.000Z" title="发表于 2025-08-04 16:11:04">2025-08-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/02.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By austin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴认识你</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d = OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:true,models:[{"path":"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","mobilePosition":[-10,23],"mobileScale":0.1,"mobileStageStyle":{"width":180,"height":166},"motionPreloadStrategy":"IDLE","position":[-10,35],"scale":0.15,"stageStyle":{"width":250,"height":250}},{"path":"https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json","scale":0.12,"position":[0,0],"stageStyle":{"width":250},"mobileScale":0.08,"mobilePosition":[0,0],"mobileStageStyle":{"width":180}},{"path":"https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json","scale":0.12,"position":[0,0],"mobileScale":0.08,"mobilePosition":[0,0],"mobileStageStyle":{"width":180},"stageStyle":{"width":250}},{"path":"https://model.oml2d.com/Senko_Normals/senko.model3.json","position":[-10,20]}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:false,tips:{style: {"width":230,"height":120,"left":"calc(50% - 20px)","top":"-100px"},mobileStyle: {"width":180,"height":80,"left":"calc(50% - 30px)","top":"-100px"},idleTips:{interval:15000,message:function(){
  return axios.get('https://v1.hitokoto.cn?c=i')
    .then(function (response) {
      return response.data.hitokoto ;
    })
    .catch(function (error) {
      console.error(error);
    });
}
}}});</script><!-- hexo injector body_end end --></body></html>